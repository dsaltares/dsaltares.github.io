<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/touch-icon-144-precomposed.png"/><title>Colisiones IV: Tests de colisión · David Saltares</title><meta name="robots" content="index,follow"/><meta name="description" content="Engineering Leadership &amp; Software Development"/><meta property="og:title" content="Colisiones IV: Tests de colisión · David Saltares"/><meta property="og:description" content="Engineering Leadership &amp; Software Development"/><meta property="og:url" content="https://saltares.com/colisiones-iv-tests-de-colision"/><meta property="og:type" content="website"/><link rel="canonical" href="https://saltares.com/colisiones-iv-tests-de-colision"/><meta name="keywords" content=""/><meta name="next-head-count" content="12"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/_next/static/css/1e80e7c82199c580.css" as="style"/><link rel="stylesheet" href="/_next/static/css/1e80e7c82199c580.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-24470d78cf61f77f.js" defer=""></script><script src="/_next/static/chunks/framework-9b5d6ec4444c80fa.js" defer=""></script><script src="/_next/static/chunks/main-e42aac98337d61c6.js" defer=""></script><script src="/_next/static/chunks/pages/_app-89283805d41ea493.js" defer=""></script><script src="/_next/static/chunks/c16184b3-9b756f0214555638.js" defer=""></script><script src="/_next/static/chunks/2cca2479-c0f2c9f2f2dc1702.js" defer=""></script><script src="/_next/static/chunks/252-64d0c1a5eecbfabd.js" defer=""></script><script src="/_next/static/chunks/167-7d296999b3b0013a.js" defer=""></script><script src="/_next/static/chunks/962-68c39fb6207889be.js" defer=""></script><script src="/_next/static/chunks/673-8982310ab2fdaad5.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bslug%5D-d0bad99a4f6f3b56.js" defer=""></script><script src="/_next/static/EE-xw-fh3I6yG7kZmQMUd/_buildManifest.js" defer=""></script><script src="/_next/static/EE-xw-fh3I6yG7kZmQMUd/_ssgManifest.js" defer=""></script><style data-href="https://fonts.googleapis.com/css2?family=PT+Sans:wght@400;700&display=swap">@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79P0Y.woff) format('woff')}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh4Oo.woff) format('woff')}@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79D0-ExcOPIDUg-g.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79D0aExcOPIDUg-g.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79D0yExcOPIDUg-g.woff2) format('woff2');unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79D0KExcOPIDU.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh0OOtLR8a8zILig.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh0OqtLR8a8zILig.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh0OCtLR8a8zILig.woff2) format('woff2');unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh0O6tLR8a8zI.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><div class="flex flex-col md:flex-row font-sans text-xl w-full"><aside class="md:max-w-[360px] bg-primary px-10 py-10 text-white text-xl md:fixed md:top-0 md:left-0 md:h-full flex flex-col justify-end items-center md:items-start"><div><a href="/"><div class="mb-5"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27200%27%20height=%27200%27/%3e"/></span><img alt="profile picture" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="rounded-full" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="profile picture" src="/img/profile.webp" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" class="rounded-full" loading="lazy"/></noscript></span></div><h1 class="text-white font-bold text-4xl leading-10">David Saltares</h1></a></div><p class="text-contentLight text-2xl mb-5 leading-9 text-center md:text-left">Engineering Leadership &amp; Software Development</p><a href="https://tinyletter.com/dsaltares/"><p class="mb-5">✉️ Subscribe</p></a><nav><ul class="mb-5 flex flex-col items-center md:items-start list-none pl-0"><li class="leading-7"><a href="/">Blog</a></li><li class="leading-7"><a href="/about-me/">About</a></li><li class="leading-7"><a href="/apps-tools/">Apps &amp; Tools</a></li><li class="leading-7"><a href="/game-jams/">Game Jams</a></li><li class="leading-7"><a href="/games/">Games</a></li><li class="leading-7"><a href="/libgdx-cross-platform-game-development-cookbook/">Libgdx Cookbook</a></li></ul></nav><ul class="mb-5 list-none pl-0"><li class="inline"><a aria-label="Github profile" href="https://github.com/dsaltares"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="square-github" class="svg-inline--fa fa-square-github text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM277.3 415.7c-8.4 1.5-11.5-3.7-11.5-8 0-5.4.2-33 .2-55.3 0-15.6-5.2-25.5-11.3-30.7 37-4.1 76-9.2 76-73.1 0-18.2-6.5-27.3-17.1-39 1.7-4.3 7.4-22-1.7-45-13.9-4.3-45.7 17.9-45.7 17.9-13.2-3.7-27.5-5.6-41.6-5.6-14.1 0-28.4 1.9-41.6 5.6 0 0-31.8-22.2-45.7-17.9-9.1 22.9-3.5 40.6-1.7 45-10.6 11.7-15.6 20.8-15.6 39 0 63.6 37.3 69 74.3 73.1-4.8 4.3-9.1 11.7-10.6 22.3-9.5 4.3-33.8 11.7-48.3-13.9-9.1-15.8-25.5-17.1-25.5-17.1-16.2-.2-1.1 10.2-1.1 10.2 10.8 5 18.4 24.2 18.4 24.2 9.7 29.7 56.1 19.7 56.1 19.7 0 13.9.2 36.5.2 40.6 0 4.3-3 9.5-11.5 8-66-22.1-112.2-84.9-112.2-158.3 0-91.8 70.2-161.5 162-161.5S388 165.6 388 257.4c.1 73.4-44.7 136.3-110.7 158.3zm-98.1-61.1c-1.9.4-3.7-.4-3.9-1.7-.2-1.5 1.1-2.8 3-3.2 1.9-.2 3.7.6 3.9 1.9.3 1.3-1 2.6-3 3zm-9.5-.9c0 1.3-1.5 2.4-3.5 2.4-2.2.2-3.7-.9-3.7-2.4 0-1.3 1.5-2.4 3.5-2.4 1.9-.2 3.7.9 3.7 2.4zm-13.7-1.1c-.4 1.3-2.4 1.9-4.1 1.3-1.9-.4-3.2-1.9-2.8-3.2.4-1.3 2.4-1.9 4.1-1.5 2 .6 3.3 2.1 2.8 3.4zm-12.3-5.4c-.9 1.1-2.8.9-4.3-.6-1.5-1.3-1.9-3.2-.9-4.1.9-1.1 2.8-.9 4.3.6 1.3 1.3 1.8 3.3.9 4.1zm-9.1-9.1c-.9.6-2.6 0-3.7-1.5s-1.1-3.2 0-3.9c1.1-.9 2.8-.2 3.7 1.3 1.1 1.5 1.1 3.3 0 4.1zm-6.5-9.7c-.9.9-2.4.4-3.5-.6-1.1-1.3-1.3-2.8-.4-3.5.9-.9 2.4-.4 3.5.6 1.1 1.3 1.3 2.8.4 3.5zm-6.7-7.4c-.4.9-1.7 1.1-2.8.4-1.3-.6-1.9-1.7-1.5-2.6.4-.6 1.5-.9 2.8-.4 1.3.7 1.9 1.8 1.5 2.6z"></path></svg></a></li><li class="inline"><a aria-label="Linkedin profile" href="https://www.linkedin.com/in/davidsaltares/"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="linkedin" class="svg-inline--fa fa-linkedin text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg></a></li><li class="inline"><a aria-label="Twitter profile" href="https://twitter.com/dsaltares"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="square-twitter" class="svg-inline--fa fa-square-twitter text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-48.9 158.8c.2 2.8.2 5.7.2 8.5 0 86.7-66 186.6-186.6 186.6-37.2 0-71.7-10.8-100.7-29.4 5.3.6 10.4.8 15.8.8 30.7 0 58.9-10.4 81.4-28-28.8-.6-53-19.5-61.3-45.5 10.1 1.5 19.2 1.5 29.6-1.2-30-6.1-52.5-32.5-52.5-64.4v-.8c8.7 4.9 18.9 7.9 29.6 8.3a65.447 65.447 0 0 1-29.2-54.6c0-12.2 3.2-23.4 8.9-33.1 32.3 39.8 80.8 65.8 135.2 68.6-9.3-44.5 24-80.6 64-80.6 18.9 0 35.9 7.9 47.9 20.7 14.8-2.8 29-8.3 41.6-15.8-4.9 15.2-15.2 28-28.8 36.1 13.2-1.4 26-5.1 37.8-10.2-8.9 13.1-20.1 24.7-32.9 34z"></path></svg></a></li><li class="inline"><a aria-label="RSS feed" href="https://saltares.com/index.xml"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="square-rss" class="svg-inline--fa fa-square-rss text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M64 32C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V96c0-35.3-28.7-64-64-64H64zM96 136c0-13.3 10.7-24 24-24c137 0 248 111 248 248c0 13.3-10.7 24-24 24s-24-10.7-24-24c0-110.5-89.5-200-200-200c-13.3 0-24-10.7-24-24zm0 96c0-13.3 10.7-24 24-24c83.9 0 152 68.1 152 152c0 13.3-10.7 24-24 24s-24-10.7-24-24c0-57.4-46.6-104-104-104c-13.3 0-24-10.7-24-24zm64 120c0 17.7-14.3 32-32 32s-32-14.3-32-32s14.3-32 32-32s32 14.3 32 32z"></path></svg></a></li><li class="inline"><a rel="me" href="https://fosstodon.org/@dsaltares"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="mastodon" class="svg-inline--fa fa-mastodon text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48 0 0 0-63.72 28.5-63.72 125.7 0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54 0 0 1-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"></path></svg></a></li></ul><p class="text-contentLight text-lg">© 2023 David Saltares.</p></aside><div class="md:max-w-[360px] w-full hidden md:block flex-grow-0 flex-shrink-0"></div><div class="flex flex-col main-content"><main class="w-full max-w-[720px] pr-4 py-10 pl-5 md:py-20 md:pl-20"><article class="text-content mb-10"><div><a href="/colisiones-iv-tests-de-colision/"><h1 class="font-bold text-4xl mb-2 text-primary">Colisiones IV: Tests de colisión</h1></a><p class="flex text-contentLight mb-1">Feb 15 2011 · 8 min read<span> · </span><a class="text-contentLink" href="/colisiones-iv-tests-de-colision/#disqus_thread">Comments</a></p><div class="mb-3"><div class="flex flex-row gap-1"><a class="px-2 py-1 bg-slate-900 text-white rounded font-bold text-sm" href="/categories/games-development/">Games development</a></div></div></div><img class="mb-1" src="/img/wp/colisiones-4.webp" alt="colisiones-4.png"/>
<p>Entregas:</p>
<ul>
<li><a class="text-contentLink text-lg" href="/proyectos/pfc/sion-tower/colisiones-i-introduccion-requisitos-y-alternativas/">Colisiones I: Introducción, requisitos y alternativas</a></li>
<li><a class="text-contentLink text-lg" href="/proyectos/pfc/sion-tower/colisiones-ii-diseno-general-de-stc/">Colisiones II: Diseño general de STC</a></li>
<li><a class="text-contentLink text-lg" href="/proyectos/pfc/sion-tower/colisiones-iii-shape-y-collision-dispatching/">Colisiones III: Shape y Collision Dispatching</a></li>
<li><em>Colisiones IV: Tests de colisión</em></li>
</ul>
<p>En la cuarta entrega de la serie de artículos de documentación sobre el <strong>sistema de detección de colisiones de Sion Tower</strong> (STC) trataremos en profundidad los <strong>tests de colisión</strong>. Hasta ahora habíamos visto como funciona la clase abstracta Shape y sus implementaciones así como el Collision Dispatching. Este texto no pretende demostrar la validez de los algoritmos expuestos por la mediana complejidad que algunos entrañan, para una explicación más extensa sugiero acudir a las referencias contenidas en la sección de bibliografía.</p>
<p>Para cada test se ofrece una breve explicación, un diagrama aclaratorio y el algoritmo en C++ utilizando Ogre3D y las clases que hemos visto hasta el momento.</p>
<h3>Teorema del plano de separación</h3>
<p>El <strong>Teorema del eje de separación</strong> (<a class="text-contentLink text-lg" href="http://en.wikipedia.org/wiki/Separating_axis_theorem">separating axis theorem</a>) resulta extremadamente útil en la detección de colisiones. Este teorema asegura que dados dos objetos convexos en un plano 2D existe una línea sobre la cual, las proyecciones de los dos objetos no se solapan si y sólo si los objetos son disjuntos (no tienen puntos en común). Esta línea se conoce como eje de separación. En un espacio tridimensional el eje de separación se convierte en un plano de separación. El siguiente diagrama ilustra el teorema.</p>
<img class="mb-1" src="/img/wp/separatin-axis.webp" alt="separatin-axis.png"/>
<p>En muchos tests <strong>buscaremos el plano de separación</strong>, puede que existan varios pero en el momento que encontremos el primero podremos asegurar que los objetos no colisionan (suponiendo que sus formas son convexas). En cualquier videojuego lo normal es que dos objetos cualesquiera no colisionen, por lo que es más eficiente descartar posibles intersecciones cuanto antes. Buscando planos de separación.</p>
<h3>Test Sphere-Sphere</h3>
<p>El test entre dos esferas es el más sencillo y rápido de todos. Basta con comprobar si la distancia entre los centros de ambas esferas es menor que la suma de sus radios, en tal caso existiría colisión.</p>
<img class="mb-1" src="/img/wp/test-sphere-sphere.webp" alt="test-sphere-sphere.png"/>
<p>Para calcular la distancia entre dos puntos es necesario una raíz cuadrada pero éstas son extremadamente caras. Podemos comparar la distancia al cuadrado con el cuadrado de la suma de los radios, una expresión equivalente y de mayor eficiencia.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">bool Shape::getCollisionSphereSphere(Shape* shapeA, Shape* shapeB) {
    // Hacemos la conversión (estamos seguros de que son esferas)
    Sphere* sphereA = static_cast&amp;lt;sphere *&amp;gt;(shapeA);
    Sphere* sphereB = static_cast&amp;lt;/sphere&amp;gt;&amp;lt;sphere *&amp;gt;(shapeB);

    // Hacemos el test
    Ogre::Vector3 s = sphereA-&amp;gt;getCenter() - sphereB-&amp;gt;getCenter();
    Ogre::Real totalRadius = sphereA-&amp;gt;getRadius() + sphereB-&amp;gt;getRadius();

    return (s.squaredLength() &amp;lt; = totalRadius * totalRadius);
}</code></pre></div>
<h3>Test AABB-AABB</h3>
<p>En la intersección entre cajas alineadas con los ejes emplearemos el teorema del plano de separación. Proyectamos las cajas sobre cada uno de los tres ejes y si algunas de las proyecciones no se solapan podremos asegurar que no existe colisión entre las AABB. El siguiente diagrama ilustra el test.</p>
<img class="mb-1" src="/img/wp/test-aabb-aabb.webp" alt="test-aabb-aabb.png"/>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">bool Shape::getCollisionAABBAABB(Shape* shapeA, Shape* shapeB) {
    // Hacemos la conversión (estamos seguros de que son AABBs)
    AxisAlignedBox* aabb1= static_cast&amp;lt;axisalignedbox *&amp;gt;(shapeA);
    AxisAlignedBox* aabb2 = static_cast&amp;lt;/axisalignedbox&amp;gt;&amp;lt;axisalignedbox *&amp;gt;(shapeB);

    // Hacemos el test
    return (aabb1-&amp;gt;getMaxPos().x &amp;gt; aabb2-&amp;gt;getMinPos().x &amp;amp;&amp;amp;
            aabb1-&amp;gt;getMinPos().x &amp;lt; aabb2-&amp;gt;getMaxPos().x &amp;amp;&amp;amp;
            aabb1-&amp;gt;getMaxPos().y &amp;gt; aabb2-&amp;gt;getMinPos().y &amp;amp;&amp;amp;
            aabb1-&amp;gt;getMinPos().y &amp;lt; aabb2-&amp;gt;getMaxPos().y &amp;amp;&amp;amp;
            aabb1-&amp;gt;getMaxPos().z &amp;gt; aabb2-&amp;gt;getMinPos().z &amp;amp;&amp;amp;
            aabb1-&amp;gt;getMinPos().z &amp;lt; aabb2-&amp;gt;getMaxPos().z);
}</code></pre></div>
<h3>Test Plane-Plane</h3>
<p>Los planos son infinitos por lo que la única situación en la que dos planos no colisionan es cuando estos son paralelos y no están a la misma distancia del origen. La orientación de los planos está definida por su vector normal. Si las dos normales son paralelas y la distancia con respecto al origen no coincide podremos asegurar que los planos no colisionan. Dos vectores son paralelos si su producto escalar es igual a 1.</p>
<img class="mb-1" src="/img/wp/test-plane-plane.webp" alt="test-plane-plane.png"/>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">bool Shape::getCollisionPlanePlane(Shape* shapeA, Shape* shapeB) {
    // Hacemos la conversión (estamos seguros de que son Planes)
    Plane* planeA = static_cast&amp;lt;plane *&amp;gt;(shapeA);
    Plane* planeB = static_cast&amp;lt;/plane&amp;gt;&amp;lt;plane *&amp;gt;(shapeB);

    // Hacemos el test
    Ogre::Vector3 normalA = planeA-&amp;gt;getNormal().normalisedCopy();
    Ogre::Vector3 normalB = planeB-&amp;gt;getNormal().normalisedCopy();
    return normalA.dotProduct(normalB) != 1;
}</code></pre></div>
<h3>Test Sphere-AABB</h3>
<p>En este test se pueden producir dos casos en los que existe intersección entre los objetos. El primero se da cuando el centro de la esfera está contenida en el AABB mientras que el segundo tiene lugar cuando el centro está fuera de la caja pero existe intersección (el diagrama ilustra el segundo caso). En primer lugar comprobamos si el centro de la esfera está dentro de la caja. Posteriormente recorremos los vértices del AABB y elegimos el más cercano al centro de la esfera. Si la distancia entre ambos es menor que el radio de la esfera las dos formas colisionan.</p>
<img class="mb-1" src="/img/wp/test-sphere-aabb.webp" alt="test-sphere-aabb.png"/>
<p>De nuevo, utilizamos el cuadrado de la distancia para conseguir una mayor eficiencia.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">bool Shape::getCollisionSphereAABB(Shape* shapeA, Shape* shapeB) {
    // Hacemos la conversión (estamos seguros de que A es Sphere y B es AABB)
    Sphere* sphere;
    AxisAlignedBox* aabb;
    if (shapeA-&amp;gt;getType() == SPHERE) {
        sphere = static_cast&amp;lt;sphere *&amp;gt;(shapeA);
        aabb = static_cast&amp;lt;axisalignedbox *&amp;gt;(shapeB);
    } else {
        sphere = static_cast&amp;lt;sphere *&amp;gt;(shapeB);
        aabb = static_cast&amp;lt;axisalignedbox *&amp;gt;(shapeA);
    }

    // Hacemos el test
    Ogre::Real s = 0;
    Ogre::Real d = 0;
    Ogre::Vector3 center = sphere-&amp;gt;getCenter();
    Ogre::Vector3 minPos = aabb-&amp;gt;getMinPos();
    Ogre::Vector3 maxPos = aabb-&amp;gt;getMaxPos();

    // Comprobamos si el centro de la esfera está dentro del AABB
    bool centerInsideAABB = (center.x &amp;lt; = maxPos.x &amp;amp;&amp;amp;
                             center.x &amp;gt;= minPos.x &amp;amp;&amp;amp;
                             center.y &amp;lt; = maxPos.y &amp;amp;&amp;amp;
                             center.y &amp;gt;= minPos.y &amp;amp;&amp;amp;
                             center.z &amp;lt; = maxPos.z &amp;amp;&amp;amp;
                             center.z &amp;gt;= minPos.z);

    if (centerInsideAABB)
        return true;

    // Comprobamos si la esfera y el AABB se intersectan
    for (int i = 0; i &amp;lt; 3; ++i) {
        if (sphere-&amp;gt;getCenter()[i] &amp;lt; aabb-&amp;gt;getMinPos()[i]) {
            s = sphere-&amp;gt;getCenter()[i] - aabb-&amp;gt;getMinPos()[i];
            d += s * s;
        } else if (sphere-&amp;gt;getCenter()[i] &amp;gt; aabb-&amp;gt;getMaxPos()[i]) {
            s = sphere-&amp;gt;getCenter()[i] - aabb-&amp;gt;getMaxPos()[i];
            d += s * s;
        }
    }

    return (d &amp;lt; = sphere-&amp;gt;getRadius() * sphere-&amp;gt;getRadius());
}</code></pre></div>
<h3>Test Sphere-Plane</h3>
<p>Comprobar si una esfera colisiona con un plano es tan sencillo como obtener la distancia entre ambos y compararla con el radio de la esfera como hemos hecho en otras ocasiones. La distancia entre el centro y el punto que conocemos del plano no es la distancia real entre ambas formas. Para calcular la distancia real tendremos que proyectar el vector p-c (punto del plano – centro de la esfera) sobre la normal del plano.</p>
<img class="mb-1" src="/img/wp/test-sphere-plane.webp" alt="test-sphere-plane.png"/>
<p>Sólo nos es necesario el cuadrado de la distancia y lo comprobaremos con el cuadrado del radio (para evitarnos utilizar una raíz cuadrada).</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">bool Shape::getCollisionPlaneSphere(Shape* shapeA, Shape* shapeB) {
    // Hacemos la conversión (estamos seguros de que A es Plane y B es Sphere)
    Plane* plane;
    Sphere* sphere;
    if (shapeA-&amp;gt;getType() == PLANE) {
        plane = static_cast&amp;lt;plane *&amp;gt;(shapeA);
        sphere = static_cast&amp;lt;sphere *&amp;gt;(shapeB);
    } else {
        plane = static_cast&amp;lt;plane *&amp;gt;(shapeB);
        sphere = static_cast&amp;lt;sphere *&amp;gt;(shapeA);
    }

    // Hacemos el test

    // Distancia del centro de la esfera al plano
    Ogre::Vector3 v = sphere-&amp;gt;getCenter() - plane-&amp;gt;getPosition();
    Ogre::Vector3 n = plane-&amp;gt;getNormal().normalisedCopy();
    Ogre::Real d = abs(n.dotProduct(v));

    // Si d &amp;lt; = radio, hay colisión
    return d &amp;lt;= sphere-&amp;gt;getRadius();
}</code></pre></div>
<h3>Test AABB-Plane</h3>
<p>En el test entre AABB y plano calculamos el vértice más lejano y el más cercano al plano (pmin y pmax respectivamente). Si cada punto está a un lado distinto del plano podemos asegurar que ambas formas colisionan.</p>
<img class="mb-1" src="/img/wp/test-plane-aabb.webp" alt="test-plane-aabb.png"/>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">bool Shape::getCollisionPlaneAABB(Shape* shapeA, Shape* shapeB) {
    // Hacemos la conversión (estamos seguros de que A es Plane y B es AABB)
    Plane* plane;
    AxisAlignedBox* aabb;
    if (shapeA-&amp;gt;getType() == PLANE) {
        plane = static_cast&amp;lt;plane *&amp;gt;(shapeA);
        aabb = static_cast&amp;lt;axisalignedbox *&amp;gt;(shapeB);
    } else {
        plane = static_cast&amp;lt;plane *&amp;gt;(shapeB);
        aabb = static_cast&amp;lt;axisalignedbox *&amp;gt;(shapeA);
    }

    // Hacemos el test
    Ogre::Vector3 p;
    Ogre::Vector3 n;

    for (int i = 0; i &amp;lt; 3; ++i) {
        if (plane-&amp;gt;getNormal()[i] &amp;gt;= 0) {
            p[i] = aabb-&amp;gt;getMaxPos()[i];
            n[i] = aabb-&amp;gt;getMinPos()[i];
        } else {
            p[i] = aabb-&amp;gt;getMaxPos()[i];
            n[i] = aabb-&amp;gt;getMinPos()[i];
        }
    }

    // Si p está en un lado diferente del plano que n, hay intersección
    Ogre::Real d1 = plane-&amp;gt;getNormal().dotProduct(p - plane-&amp;gt;getPosition());
    Ogre::Real d2 = plane-&amp;gt;getNormal().dotProduct(n - plane-&amp;gt;getPosition());

    return ((d1 &amp;lt; = 0 &amp;amp;&amp;amp; d2 &amp;gt;= 0) || (d1 &amp;gt;= 0 &amp;amp;&amp;amp; d2 &amp;lt; = 0));
}</code></pre></div>
<h3>Bibliografía</h3>
<p>Como podéis comprobar, hay un poco más de fundamento detrás de estos tests de lo que se ha explicado en la secciones anteriores. Para obtener más información sobre este interesante tema, recomiendo las siguientes lecturas (todo en inglés):</p>
<ul>
<li><a class="text-contentLink text-lg" href="http://realtimecollisiondetection.net/">Real Time Collision Detection</a> (Christer Ericson ): excepcional libro que cubre todo lo relacionado sobre la detección de colisiones en 3D escrito por un trabajador de Sony Computer Entertainment America.</li>
<li><a class="text-contentLink text-lg" href="http://www.gamasutra.com/view/feature/3383/simple_intersection_tests_for_games.php">Gamasutra &quot;Simple intersection tests for games&quot;</a> (Miguel Gomez): repaso por varios tests de intersección entre distintos tipos de formas (cubre cuerpos en movimiento).</li>
<li><a class="text-contentLink text-lg" href="http://www.gamasutra.com/view/feature/3190/advanced_collision_detection_.php">Gamasutra &quot;Advanced collision detection techniques&quot;</a> (Nick Bobic): técnicas de detección de colisiones, particionado del espacio y otras optimizaciones.</li>
<li><a class="text-contentLink text-lg" href="http://www.metanetsoftware.com/technique/tutorialA.html">Metanet software &quot;Collision detection and response&quot;</a>: explicación teórica sobre la detección de colisione. Cuenta con ejemplos gráficos interactivos para ilustrar cada concepto. Me la recomendó el compañero José Tomás Tocino.</li>
</ul>
<p>En el siguiente artículo lo dedicaremos a las clases Body y CollisionManager del sistema de detección de colisiones de Sion Tower.</p></article></main></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metadata":{"path":"content/post/2011-02-15-colisiones-iv-tests-de-colision.mdx","title":"Colisiones IV: Tests de colisión","date":"2011-02-15T20:43:36.000Z","categories":["Games development"],"series":null,"description":null,"slug":"colisiones-iv-tests-de-colision","readingTime":"8 min read","draft":false,"disableComments":false,"keywords":[],"banner":null},"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    img: \"img\",\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    a: \"a\",\n    em: \"em\",\n    strong: \"strong\",\n    h3: \"h3\",\n    div: \"div\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.img, {\n      src: \"/img/wp/colisiones-4.webp\",\n      alt: \"colisiones-4.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Entregas:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/proyectos/pfc/sion-tower/colisiones-i-introduccion-requisitos-y-alternativas/\",\n          children: \"Colisiones I: Introducción, requisitos y alternativas\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/proyectos/pfc/sion-tower/colisiones-ii-diseno-general-de-stc/\",\n          children: \"Colisiones II: Diseño general de STC\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/proyectos/pfc/sion-tower/colisiones-iii-shape-y-collision-dispatching/\",\n          children: \"Colisiones III: Shape y Collision Dispatching\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.em, {\n          children: \"Colisiones IV: Tests de colisión\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"En la cuarta entrega de la serie de artículos de documentación sobre el \", _jsx(_components.strong, {\n        children: \"sistema de detección de colisiones de Sion Tower\"\n      }), \" (STC) trataremos en profundidad los \", _jsx(_components.strong, {\n        children: \"tests de colisión\"\n      }), \". Hasta ahora habíamos visto como funciona la clase abstracta Shape y sus implementaciones así como el Collision Dispatching. Este texto no pretende demostrar la validez de los algoritmos expuestos por la mediana complejidad que algunos entrañan, para una explicación más extensa sugiero acudir a las referencias contenidas en la sección de bibliografía.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Para cada test se ofrece una breve explicación, un diagrama aclaratorio y el algoritmo en C++ utilizando Ogre3D y las clases que hemos visto hasta el momento.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Teorema del plano de separación\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"El \", _jsx(_components.strong, {\n        children: \"Teorema del eje de separación\"\n      }), \" (\", _jsx(_components.a, {\n        href: \"http://en.wikipedia.org/wiki/Separating_axis_theorem\",\n        children: \"separating axis theorem\"\n      }), \") resulta extremadamente útil en la detección de colisiones. Este teorema asegura que dados dos objetos convexos en un plano 2D existe una línea sobre la cual, las proyecciones de los dos objetos no se solapan si y sólo si los objetos son disjuntos (no tienen puntos en común). Esta línea se conoce como eje de separación. En un espacio tridimensional el eje de separación se convierte en un plano de separación. El siguiente diagrama ilustra el teorema.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/separatin-axis.webp\",\n      alt: \"separatin-axis.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"En muchos tests \", _jsx(_components.strong, {\n        children: \"buscaremos el plano de separación\"\n      }), \", puede que existan varios pero en el momento que encontremos el primero podremos asegurar que los objetos no colisionan (suponiendo que sus formas son convexas). En cualquier videojuego lo normal es que dos objetos cualesquiera no colisionen, por lo que es más eficiente descartar posibles intersecciones cuanto antes. Buscando planos de separación.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Test Sphere-Sphere\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"El test entre dos esferas es el más sencillo y rápido de todos. Basta con comprobar si la distancia entre los centros de ambas esferas es menor que la suma de sus radios, en tal caso existiría colisión.\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/test-sphere-sphere.webp\",\n      alt: \"test-sphere-sphere.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Para calcular la distancia entre dos puntos es necesario una raíz cuadrada pero éstas son extremadamente caras. Podemos comparar la distancia al cuadrado con el cuadrado de la suma de los radios, una expresión equivalente y de mayor eficiencia.\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"bool Shape::getCollisionSphereSphere(Shape* shapeA, Shape* shapeB) {\\n    // Hacemos la conversión (estamos seguros de que son esferas)\\n    Sphere* sphereA = static_cast\u0026lt;sphere *\u0026gt;(shapeA);\\n    Sphere* sphereB = static_cast\u0026lt;/sphere\u0026gt;\u0026lt;sphere *\u0026gt;(shapeB);\\n\\n    // Hacemos el test\\n    Ogre::Vector3 s = sphereA-\u0026gt;getCenter() - sphereB-\u0026gt;getCenter();\\n    Ogre::Real totalRadius = sphereA-\u0026gt;getRadius() + sphereB-\u0026gt;getRadius();\\n\\n    return (s.squaredLength() \u0026lt; = totalRadius * totalRadius);\\n}\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Test AABB-AABB\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"En la intersección entre cajas alineadas con los ejes emplearemos el teorema del plano de separación. Proyectamos las cajas sobre cada uno de los tres ejes y si algunas de las proyecciones no se solapan podremos asegurar que no existe colisión entre las AABB. El siguiente diagrama ilustra el test.\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/test-aabb-aabb.webp\",\n      alt: \"test-aabb-aabb.png\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"bool Shape::getCollisionAABBAABB(Shape* shapeA, Shape* shapeB) {\\n    // Hacemos la conversión (estamos seguros de que son AABBs)\\n    AxisAlignedBox* aabb1= static_cast\u0026lt;axisalignedbox *\u0026gt;(shapeA);\\n    AxisAlignedBox* aabb2 = static_cast\u0026lt;/axisalignedbox\u0026gt;\u0026lt;axisalignedbox *\u0026gt;(shapeB);\\n\\n    // Hacemos el test\\n    return (aabb1-\u0026gt;getMaxPos().x \u0026gt; aabb2-\u0026gt;getMinPos().x \u0026amp;\u0026amp;\\n            aabb1-\u0026gt;getMinPos().x \u0026lt; aabb2-\u0026gt;getMaxPos().x \u0026amp;\u0026amp;\\n            aabb1-\u0026gt;getMaxPos().y \u0026gt; aabb2-\u0026gt;getMinPos().y \u0026amp;\u0026amp;\\n            aabb1-\u0026gt;getMinPos().y \u0026lt; aabb2-\u0026gt;getMaxPos().y \u0026amp;\u0026amp;\\n            aabb1-\u0026gt;getMaxPos().z \u0026gt; aabb2-\u0026gt;getMinPos().z \u0026amp;\u0026amp;\\n            aabb1-\u0026gt;getMinPos().z \u0026lt; aabb2-\u0026gt;getMaxPos().z);\\n}\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Test Plane-Plane\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Los planos son infinitos por lo que la única situación en la que dos planos no colisionan es cuando estos son paralelos y no están a la misma distancia del origen. La orientación de los planos está definida por su vector normal. Si las dos normales son paralelas y la distancia con respecto al origen no coincide podremos asegurar que los planos no colisionan. Dos vectores son paralelos si su producto escalar es igual a 1.\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/test-plane-plane.webp\",\n      alt: \"test-plane-plane.png\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"bool Shape::getCollisionPlanePlane(Shape* shapeA, Shape* shapeB) {\\n    // Hacemos la conversión (estamos seguros de que son Planes)\\n    Plane* planeA = static_cast\u0026lt;plane *\u0026gt;(shapeA);\\n    Plane* planeB = static_cast\u0026lt;/plane\u0026gt;\u0026lt;plane *\u0026gt;(shapeB);\\n\\n    // Hacemos el test\\n    Ogre::Vector3 normalA = planeA-\u0026gt;getNormal().normalisedCopy();\\n    Ogre::Vector3 normalB = planeB-\u0026gt;getNormal().normalisedCopy();\\n    return normalA.dotProduct(normalB) != 1;\\n}\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Test Sphere-AABB\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"En este test se pueden producir dos casos en los que existe intersección entre los objetos. El primero se da cuando el centro de la esfera está contenida en el AABB mientras que el segundo tiene lugar cuando el centro está fuera de la caja pero existe intersección (el diagrama ilustra el segundo caso). En primer lugar comprobamos si el centro de la esfera está dentro de la caja. Posteriormente recorremos los vértices del AABB y elegimos el más cercano al centro de la esfera. Si la distancia entre ambos es menor que el radio de la esfera las dos formas colisionan.\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/test-sphere-aabb.webp\",\n      alt: \"test-sphere-aabb.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"De nuevo, utilizamos el cuadrado de la distancia para conseguir una mayor eficiencia.\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"bool Shape::getCollisionSphereAABB(Shape* shapeA, Shape* shapeB) {\\n    // Hacemos la conversión (estamos seguros de que A es Sphere y B es AABB)\\n    Sphere* sphere;\\n    AxisAlignedBox* aabb;\\n    if (shapeA-\u0026gt;getType() == SPHERE) {\\n        sphere = static_cast\u0026lt;sphere *\u0026gt;(shapeA);\\n        aabb = static_cast\u0026lt;axisalignedbox *\u0026gt;(shapeB);\\n    } else {\\n        sphere = static_cast\u0026lt;sphere *\u0026gt;(shapeB);\\n        aabb = static_cast\u0026lt;axisalignedbox *\u0026gt;(shapeA);\\n    }\\n\\n    // Hacemos el test\\n    Ogre::Real s = 0;\\n    Ogre::Real d = 0;\\n    Ogre::Vector3 center = sphere-\u0026gt;getCenter();\\n    Ogre::Vector3 minPos = aabb-\u0026gt;getMinPos();\\n    Ogre::Vector3 maxPos = aabb-\u0026gt;getMaxPos();\\n\\n    // Comprobamos si el centro de la esfera está dentro del AABB\\n    bool centerInsideAABB = (center.x \u0026lt; = maxPos.x \u0026amp;\u0026amp;\\n                             center.x \u0026gt;= minPos.x \u0026amp;\u0026amp;\\n                             center.y \u0026lt; = maxPos.y \u0026amp;\u0026amp;\\n                             center.y \u0026gt;= minPos.y \u0026amp;\u0026amp;\\n                             center.z \u0026lt; = maxPos.z \u0026amp;\u0026amp;\\n                             center.z \u0026gt;= minPos.z);\\n\\n    if (centerInsideAABB)\\n        return true;\\n\\n    // Comprobamos si la esfera y el AABB se intersectan\\n    for (int i = 0; i \u0026lt; 3; ++i) {\\n        if (sphere-\u0026gt;getCenter()[i] \u0026lt; aabb-\u0026gt;getMinPos()[i]) {\\n            s = sphere-\u0026gt;getCenter()[i] - aabb-\u0026gt;getMinPos()[i];\\n            d += s * s;\\n        } else if (sphere-\u0026gt;getCenter()[i] \u0026gt; aabb-\u0026gt;getMaxPos()[i]) {\\n            s = sphere-\u0026gt;getCenter()[i] - aabb-\u0026gt;getMaxPos()[i];\\n            d += s * s;\\n        }\\n    }\\n\\n    return (d \u0026lt; = sphere-\u0026gt;getRadius() * sphere-\u0026gt;getRadius());\\n}\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Test Sphere-Plane\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Comprobar si una esfera colisiona con un plano es tan sencillo como obtener la distancia entre ambos y compararla con el radio de la esfera como hemos hecho en otras ocasiones. La distancia entre el centro y el punto que conocemos del plano no es la distancia real entre ambas formas. Para calcular la distancia real tendremos que proyectar el vector p-c (punto del plano – centro de la esfera) sobre la normal del plano.\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/test-sphere-plane.webp\",\n      alt: \"test-sphere-plane.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Sólo nos es necesario el cuadrado de la distancia y lo comprobaremos con el cuadrado del radio (para evitarnos utilizar una raíz cuadrada).\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"bool Shape::getCollisionPlaneSphere(Shape* shapeA, Shape* shapeB) {\\n    // Hacemos la conversión (estamos seguros de que A es Plane y B es Sphere)\\n    Plane* plane;\\n    Sphere* sphere;\\n    if (shapeA-\u0026gt;getType() == PLANE) {\\n        plane = static_cast\u0026lt;plane *\u0026gt;(shapeA);\\n        sphere = static_cast\u0026lt;sphere *\u0026gt;(shapeB);\\n    } else {\\n        plane = static_cast\u0026lt;plane *\u0026gt;(shapeB);\\n        sphere = static_cast\u0026lt;sphere *\u0026gt;(shapeA);\\n    }\\n\\n    // Hacemos el test\\n\\n    // Distancia del centro de la esfera al plano\\n    Ogre::Vector3 v = sphere-\u0026gt;getCenter() - plane-\u0026gt;getPosition();\\n    Ogre::Vector3 n = plane-\u0026gt;getNormal().normalisedCopy();\\n    Ogre::Real d = abs(n.dotProduct(v));\\n\\n    // Si d \u0026lt; = radio, hay colisión\\n    return d \u0026lt;= sphere-\u0026gt;getRadius();\\n}\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Test AABB-Plane\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"En el test entre AABB y plano calculamos el vértice más lejano y el más cercano al plano (pmin y pmax respectivamente). Si cada punto está a un lado distinto del plano podemos asegurar que ambas formas colisionan.\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/test-plane-aabb.webp\",\n      alt: \"test-plane-aabb.png\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"bool Shape::getCollisionPlaneAABB(Shape* shapeA, Shape* shapeB) {\\n    // Hacemos la conversión (estamos seguros de que A es Plane y B es AABB)\\n    Plane* plane;\\n    AxisAlignedBox* aabb;\\n    if (shapeA-\u0026gt;getType() == PLANE) {\\n        plane = static_cast\u0026lt;plane *\u0026gt;(shapeA);\\n        aabb = static_cast\u0026lt;axisalignedbox *\u0026gt;(shapeB);\\n    } else {\\n        plane = static_cast\u0026lt;plane *\u0026gt;(shapeB);\\n        aabb = static_cast\u0026lt;axisalignedbox *\u0026gt;(shapeA);\\n    }\\n\\n    // Hacemos el test\\n    Ogre::Vector3 p;\\n    Ogre::Vector3 n;\\n\\n    for (int i = 0; i \u0026lt; 3; ++i) {\\n        if (plane-\u0026gt;getNormal()[i] \u0026gt;= 0) {\\n            p[i] = aabb-\u0026gt;getMaxPos()[i];\\n            n[i] = aabb-\u0026gt;getMinPos()[i];\\n        } else {\\n            p[i] = aabb-\u0026gt;getMaxPos()[i];\\n            n[i] = aabb-\u0026gt;getMinPos()[i];\\n        }\\n    }\\n\\n    // Si p está en un lado diferente del plano que n, hay intersección\\n    Ogre::Real d1 = plane-\u0026gt;getNormal().dotProduct(p - plane-\u0026gt;getPosition());\\n    Ogre::Real d2 = plane-\u0026gt;getNormal().dotProduct(n - plane-\u0026gt;getPosition());\\n\\n    return ((d1 \u0026lt; = 0 \u0026amp;\u0026amp; d2 \u0026gt;= 0) || (d1 \u0026gt;= 0 \u0026amp;\u0026amp; d2 \u0026lt; = 0));\\n}\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Bibliografía\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Como podéis comprobar, hay un poco más de fundamento detrás de estos tests de lo que se ha explicado en la secciones anteriores. Para obtener más información sobre este interesante tema, recomiendo las siguientes lecturas (todo en inglés):\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"http://realtimecollisiondetection.net/\",\n          children: \"Real Time Collision Detection\"\n        }), \" (Christer Ericson ): excepcional libro que cubre todo lo relacionado sobre la detección de colisiones en 3D escrito por un trabajador de Sony Computer Entertainment America.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"http://www.gamasutra.com/view/feature/3383/simple_intersection_tests_for_games.php\",\n          children: \"Gamasutra \\\"Simple intersection tests for games\\\"\"\n        }), \" (Miguel Gomez): repaso por varios tests de intersección entre distintos tipos de formas (cubre cuerpos en movimiento).\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"http://www.gamasutra.com/view/feature/3190/advanced_collision_detection_.php\",\n          children: \"Gamasutra \\\"Advanced collision detection techniques\\\"\"\n        }), \" (Nick Bobic): técnicas de detección de colisiones, particionado del espacio y otras optimizaciones.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"http://www.metanetsoftware.com/technique/tutorialA.html\",\n          children: \"Metanet software \\\"Collision detection and response\\\"\"\n        }), \": explicación teórica sobre la detección de colisione. Cuenta con ejemplos gráficos interactivos para ilustrar cada concepto. Me la recomendó el compañero José Tomás Tocino.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"En el siguiente artículo lo dedicaremos a las clases Body y CollisionManager del sistema de detección de colisiones de Sion Tower.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","scope":{}},"series":null},"__N_SSG":true},"page":"/[slug]","query":{"slug":"colisiones-iv-tests-de-colision"},"buildId":"EE-xw-fh3I6yG7kZmQMUd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>