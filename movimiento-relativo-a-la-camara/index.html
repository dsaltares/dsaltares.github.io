<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/touch-icon-144-precomposed.png"/><title>Movimiento relativo a la cámara · David Saltares</title><meta name="robots" content="index,follow"/><meta name="description" content="Engineering Leadership &amp; Software Development"/><meta property="og:title" content="Movimiento relativo a la cámara · David Saltares"/><meta property="og:description" content="Engineering Leadership &amp; Software Development"/><meta property="og:url" content="https://saltares.com/movimiento-relativo-a-la-camara"/><meta property="og:type" content="website"/><link rel="canonical" href="https://saltares.com/movimiento-relativo-a-la-camara"/><meta name="keywords" content=""/><meta name="next-head-count" content="12"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/_next/static/css/592216306eff0874.css" as="style"/><link rel="stylesheet" href="/_next/static/css/592216306eff0874.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-59abf025137dee37.js" defer=""></script><script src="/_next/static/chunks/framework-9b5d6ec4444c80fa.js" defer=""></script><script src="/_next/static/chunks/main-e42aac98337d61c6.js" defer=""></script><script src="/_next/static/chunks/pages/_app-89283805d41ea493.js" defer=""></script><script src="/_next/static/chunks/c16184b3-9b756f0214555638.js" defer=""></script><script src="/_next/static/chunks/2cca2479-c0f2c9f2f2dc1702.js" defer=""></script><script src="/_next/static/chunks/252-64d0c1a5eecbfabd.js" defer=""></script><script src="/_next/static/chunks/167-7d296999b3b0013a.js" defer=""></script><script src="/_next/static/chunks/962-68c39fb6207889be.js" defer=""></script><script src="/_next/static/chunks/673-8982310ab2fdaad5.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bslug%5D-73432d84cbff39d9.js" defer=""></script><script src="/_next/static/5YKEeJrSBspihiTxQqQYZ/_buildManifest.js" defer=""></script><script src="/_next/static/5YKEeJrSBspihiTxQqQYZ/_ssgManifest.js" defer=""></script><style data-href="https://fonts.googleapis.com/css2?family=PT+Sans:wght@400;700&display=swap">@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79P0Y.woff) format('woff')}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh4Oo.woff) format('woff')}@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79D0-ExcOPIDUg-g.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79D0aExcOPIDUg-g.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79D0yExcOPIDUg-g.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79D0KExcOPIDU.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh0OOtLR8a8zILig.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh0OqtLR8a8zILig.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh0OCtLR8a8zILig.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh0O6tLR8a8zI.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><div class="flex flex-col md:flex-row font-sans text-xl w-full"><aside class="md:max-w-[360px] bg-primary px-10 py-10 text-white text-xl md:fixed md:top-0 md:left-0 md:h-full flex flex-col justify-end items-center md:items-start"><div><a href="/"><div class="mb-5"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27200%27%20height=%27200%27/%3e"/></span><img alt="profile picture" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="rounded-full" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="profile picture" src="/img/profile.webp" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" class="rounded-full" loading="lazy"/></noscript></span></div><h1 class="text-white font-bold text-4xl leading-10">David Saltares</h1></a></div><p class="text-contentLight text-2xl mb-5 leading-9 text-center md:text-left">Engineering Leadership &amp; Software Development</p><a href="https://tinyletter.com/dsaltares/"><p class="mb-5">✉️ Subscribe</p></a><nav><ul class="mb-5 flex flex-col items-center md:items-start list-none pl-0"><li class="leading-7"><a href="/">Blog</a></li><li class="leading-7"><a href="/about-me/">About</a></li><li class="leading-7"><a href="/apps-tools/">Apps &amp; Tools</a></li><li class="leading-7"><a href="/game-jams/">Game Jams</a></li><li class="leading-7"><a href="/games/">Games</a></li><li class="leading-7"><a href="/libgdx-cross-platform-game-development-cookbook/">Libgdx Cookbook</a></li></ul></nav><ul class="mb-5 list-none pl-0"><li class="inline"><a aria-label="Github profile" href="https://github.com/dsaltares"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="square-github" class="svg-inline--fa fa-square-github text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM277.3 415.7c-8.4 1.5-11.5-3.7-11.5-8 0-5.4.2-33 .2-55.3 0-15.6-5.2-25.5-11.3-30.7 37-4.1 76-9.2 76-73.1 0-18.2-6.5-27.3-17.1-39 1.7-4.3 7.4-22-1.7-45-13.9-4.3-45.7 17.9-45.7 17.9-13.2-3.7-27.5-5.6-41.6-5.6-14.1 0-28.4 1.9-41.6 5.6 0 0-31.8-22.2-45.7-17.9-9.1 22.9-3.5 40.6-1.7 45-10.6 11.7-15.6 20.8-15.6 39 0 63.6 37.3 69 74.3 73.1-4.8 4.3-9.1 11.7-10.6 22.3-9.5 4.3-33.8 11.7-48.3-13.9-9.1-15.8-25.5-17.1-25.5-17.1-16.2-.2-1.1 10.2-1.1 10.2 10.8 5 18.4 24.2 18.4 24.2 9.7 29.7 56.1 19.7 56.1 19.7 0 13.9.2 36.5.2 40.6 0 4.3-3 9.5-11.5 8-66-22.1-112.2-84.9-112.2-158.3 0-91.8 70.2-161.5 162-161.5S388 165.6 388 257.4c.1 73.4-44.7 136.3-110.7 158.3zm-98.1-61.1c-1.9.4-3.7-.4-3.9-1.7-.2-1.5 1.1-2.8 3-3.2 1.9-.2 3.7.6 3.9 1.9.3 1.3-1 2.6-3 3zm-9.5-.9c0 1.3-1.5 2.4-3.5 2.4-2.2.2-3.7-.9-3.7-2.4 0-1.3 1.5-2.4 3.5-2.4 1.9-.2 3.7.9 3.7 2.4zm-13.7-1.1c-.4 1.3-2.4 1.9-4.1 1.3-1.9-.4-3.2-1.9-2.8-3.2.4-1.3 2.4-1.9 4.1-1.5 2 .6 3.3 2.1 2.8 3.4zm-12.3-5.4c-.9 1.1-2.8.9-4.3-.6-1.5-1.3-1.9-3.2-.9-4.1.9-1.1 2.8-.9 4.3.6 1.3 1.3 1.8 3.3.9 4.1zm-9.1-9.1c-.9.6-2.6 0-3.7-1.5s-1.1-3.2 0-3.9c1.1-.9 2.8-.2 3.7 1.3 1.1 1.5 1.1 3.3 0 4.1zm-6.5-9.7c-.9.9-2.4.4-3.5-.6-1.1-1.3-1.3-2.8-.4-3.5.9-.9 2.4-.4 3.5.6 1.1 1.3 1.3 2.8.4 3.5zm-6.7-7.4c-.4.9-1.7 1.1-2.8.4-1.3-.6-1.9-1.7-1.5-2.6.4-.6 1.5-.9 2.8-.4 1.3.7 1.9 1.8 1.5 2.6z"></path></svg></a></li><li class="inline"><a aria-label="Linkedin profile" href="https://www.linkedin.com/in/davidsaltares/"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="linkedin" class="svg-inline--fa fa-linkedin text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg></a></li><li class="inline"><a aria-label="Twitter profile" href="https://twitter.com/dsaltares"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="square-twitter" class="svg-inline--fa fa-square-twitter text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-48.9 158.8c.2 2.8.2 5.7.2 8.5 0 86.7-66 186.6-186.6 186.6-37.2 0-71.7-10.8-100.7-29.4 5.3.6 10.4.8 15.8.8 30.7 0 58.9-10.4 81.4-28-28.8-.6-53-19.5-61.3-45.5 10.1 1.5 19.2 1.5 29.6-1.2-30-6.1-52.5-32.5-52.5-64.4v-.8c8.7 4.9 18.9 7.9 29.6 8.3a65.447 65.447 0 0 1-29.2-54.6c0-12.2 3.2-23.4 8.9-33.1 32.3 39.8 80.8 65.8 135.2 68.6-9.3-44.5 24-80.6 64-80.6 18.9 0 35.9 7.9 47.9 20.7 14.8-2.8 29-8.3 41.6-15.8-4.9 15.2-15.2 28-28.8 36.1 13.2-1.4 26-5.1 37.8-10.2-8.9 13.1-20.1 24.7-32.9 34z"></path></svg></a></li><li class="inline"><a aria-label="RSS feed" href="https://saltares.com/index.xml"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="square-rss" class="svg-inline--fa fa-square-rss text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M64 32C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V96c0-35.3-28.7-64-64-64H64zM96 136c0-13.3 10.7-24 24-24c137 0 248 111 248 248c0 13.3-10.7 24-24 24s-24-10.7-24-24c0-110.5-89.5-200-200-200c-13.3 0-24-10.7-24-24zm0 96c0-13.3 10.7-24 24-24c83.9 0 152 68.1 152 152c0 13.3-10.7 24-24 24s-24-10.7-24-24c0-57.4-46.6-104-104-104c-13.3 0-24-10.7-24-24zm64 120c0 17.7-14.3 32-32 32s-32-14.3-32-32s14.3-32 32-32s32 14.3 32 32z"></path></svg></a></li><li class="inline"><a rel="me" href="https://fosstodon.org/@dsaltares"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="mastodon" class="svg-inline--fa fa-mastodon text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48 0 0 0-63.72 28.5-63.72 125.7 0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54 0 0 1-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"></path></svg></a></li></ul><p class="text-contentLight text-lg">© 2023 David Saltares.</p></aside><div class="md:max-w-[360px] w-full hidden md:block flex-grow-0 flex-shrink-0"></div><div class="flex flex-col main-content"><main class="w-full max-w-[720px] pr-4 py-10 pl-5 md:py-20 md:pl-20"><article class="text-content mb-10"><div><a href="/movimiento-relativo-a-la-camara/"><h1 class="font-bold text-4xl mb-2 text-primary">Movimiento relativo a la cámara</h1></a><p class="flex text-contentLight mb-1">Dec 26 2010 · 6 min read<span> · </span><a class="text-contentLink" href="/movimiento-relativo-a-la-camara/#disqus_thread">Comments</a></p><div class="mb-3"><div class="flex flex-row gap-1"><a class="px-2 py-1 bg-slate-900 text-white rounded font-bold text-sm" href="/categories/games-development/">Games development</a></div></div></div><img class="mb-1" src="/img/wp/movimiento-camara.webp" alt="movimiento-camara.png"/>
<p>En la mayoría de videojuegos en tercera persona, <strong>la dirección hacia la que se mueve el personaje depende de la orientación de la cámara</strong>. A pesar de que Sion Tower es un tower defense, controlamos a un personaje en tercera persona y, por tanto, debía incorporar este sistema. Estos días he estado exprimiendo los sesos para implementar dicho movimiento. ¡Por fin! Tras decenas de diagramas con vectores, ángulos y sistemas de coordenadas, lo he conseguido. En este artículo <strong>explico un sencillo algoritmo para conseguirlo</strong>.</p>
<h3>¿Qué queremos conseguir?</h3>
<p>El siguiente diagrama muestra el <strong>sistema de coordenadas de Ogre</strong>. Imaginad que nuestro personaje se encuentra en el origen <em>p = (0, 0, 0)</em> y que la cámara está en el <em>c = (0, 0, 50)</em> mirando hacia el origen. Nuestras teclas de movimiento son las clásicas: WASD. Al pulsar W el personaje debe moverse en la dirección negativa del eje Z, en cambio, si pulsamos D deberá hacerlo en la dirección positiva del eje X.</p>
<p>En cambio, si la cámara se situase en <em>c = (50, 0, 0)</em> mirando a <em>(0, 0, 0)</em> las teclas no tendrían el mismo efecto en términos absolutos, aunque se mantiene idéntico si tomamos como punto de referencia a la cámara. Si pulsamos W el personaje se desplazará en la dirección negativa del eje X. En el caso de que pulsemos D, el personaje se dirigirá en la dirección negativa del eje Z.</p>
<img class="mb-1" src="/img/wp/coordenadas.webp" alt="coordenadas.png"/>
<p>Por supuesto, <strong>el personaje deberá girarse</strong> para mirar hacia la dirección del desplazamiento. A continuación, detallamos la manera de implementar este sistema de movimiento.</p>
<h3>Algoritmo: objetos implicados</h3>
<p>Este pequeño algoritmo está orientado al motor de renderizado Ogre3D y la biblioteca de dispositivos de entrada OIS aunque su filosofía es válida para otras herramientas. Lo ideal sería utilizar clases para el personaje y otros elementos aunque, en esta ocasión, he preferido no hacerlo en favor de la simplicidad del ejemplo.</p>
<p>Partimos de los siguientes objetos:</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">Ogre::SceneNode* nodoPersonaje; // Nodo que representa al personaje
Ogre::Vector3 direccionObjetivo; // Relativa a la cámara
Ogre::Vector3 direccionActual; // Relativa a la cámara
Ogre::Vector3 velocidad; // Velocidad del personaje
bool andando; // true si el personaje se está desplazando
OIS::Keyboard* teclado; // Teclado para controlar al personaje</code></pre></div>
<h3>Algoritmo: desplazamiento del personaje</h3>
<p>En cada frame debemos <strong>tomar la dirección de la cámara</strong> y quedarnos con su componente x y z ya que nos movemos en el plano. Esa será nuestra dirección <em>&quot;hacia delante&quot;</em>. Es muy sencillo obtener la dirección &quot;<em>hacia la derecha&quot;</em>, simplemente intercambiamos las componentes x y z cambiándole el signo a la z de <em>&quot;hacia delante&quot;</em>.</p>
<p><strong>La dirección objetivo</strong> de este frame se puede calcular consultando las <strong>pulsaciones de las teclas</strong> y <strong>combinando los dos vectores</strong> anteriores utilizando sumas o restas. Nos podremos mover en 8 direcciones distintas. Por ejemplo, si deseamos dirigirnos hacia atrás a la izquierda tendremos: <em>direccionObjetivo = -delante – derecha</em>. Finalmente, <strong>la dirección objetivo debe ser normalizada</strong>, es decir, que el módulo del vector sea igual a 1. Esto es muy importante si no queremos que la velocidad del personaje se vea alterada. Finalmente, aplicamos el desplazamiento teniendo en cuenta la velocidad, la dirección y el tiempo en milisegundos desde el último frame. Esta técnica se conoce como <strong>LERP</strong> (Linear Interpolation).</p>
<h3>Algoritmo: orientación del personaje</h3>
<p>Sólo nos queda corregir la orientación del personaje para que mire hacia la dirección en la que se desplaza. Ogre pone a nuestra disposición el método <em>Vector3::getRotationTo</em> que, dado un vector nos devuelve el cuaternio a aplicar de forma que tras la rotación quede alineado con el segundo. <strong>Los cuaternios se utilizan para representar rotaciones</strong> en el espacio y están compuestos por un ángulo y un eje (en este caso el y). Si multiplicamos la rotación necesaria por la que ya posee el nodo del personaje, éste mirará hacia donde deseamos. Es importante el orden de los operadores ya que el producto de cuaternios no es conmutativo.</p>
<h3>Algoritmo: código completo</h3>
<p>He aquí el código completo:</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">using namespace Ogre;

void EstadoJuego::actualizarPersonaje(Ogre::Real deltaT) {
    // Tomamos la dirección de la cámara
    Vector3 delante = camara-&amp;gt;getDirection();
    delante.y = 0;

    // Vector relativo a la cámara, ortogonal hacia su derecha
    Vector3 derecha(-delante.z, 0, delante.x);

    // Calculamos la dirección objetivo en función de la pulsación de las
    // teclas.
    if (teclado-&amp;gt;isKeyDown(OIS::KC_W) &amp;amp;&amp;amp; teclado-&amp;gt;isKeyDown(OIS::KC_D)) {
        direccionObjetivo = delante + derecha;
        andando = true;
    }
    else if (teclado-&amp;gt;isKeyDown(OIS::KC_W) &amp;amp;&amp;amp; teclado-&amp;gt;isKeyDown(OIS::KC_A)) {
        direccionObjetivo = delante - derecha;
        andando = true;
    }
    else if (teclado-&amp;gt;isKeyDown(OIS::KC_S) &amp;amp;&amp;amp; teclado-&amp;gt;isKeyDown(OIS::KC_D)) {
        direccionObjetivo = -delante + derecha;
        andando = true;
    }
    else if (teclado-&amp;gt;isKeyDown(OIS::KC_S) &amp;amp;&amp;amp; teclado-&amp;gt;isKeyDown(OIS::KC_A)) {
        direccionObjetivo = -delante - derecha;
        andando = true;
    }
    else if (teclado-&amp;gt;isKeyDown(OIS::KC_W)) {
        direccionObjetivo = delante;
        andando = true;
    }
    else if (teclado-&amp;gt;isKeyDown(OIS::KC_S)) {
        direccionObjetivo = -delante;
        andando = true;
    }
    else if (teclado-&amp;gt;isKeyDown(OIS::KC_D)) {
        direccionObjetivo = derecha;
        andando = true;
    }
    else if (teclado-&amp;gt;isKeyDown(OIS::KC_A)){
        direccionObjetivo = -derecha;
        andando = true;
    }
    else
        andando = false;

    // Normalizamos el vector direccion
    direccionObjetivo.normalise();

    // Si debemos desplazarnos, aplicamos la traslación y calculamos la
    // rotación a aplicar
    if (andando) {
        nodoPersonaje-&amp;gt;translate(velocidad * direccionObjetivo * deltaT,
                                 Node::TS_WORLD);
        if (direccionObjetivo != direccionActual) {
            Quaternion rotacion = direccionActual.getRotationTo(direccionObjetivo,
                                                                Vector3(0, 1, 0));
            Quaternion rotacionActual = nodoPersonaje-&amp;gt;getOrientation()
            nodoPersonaje-&amp;gt;setOrientation(orientacion * rotacionActual);
            direccionActual = direccionObjetivo;
        }
    }
}</code></pre></div>
<h3>Posibles mejoras</h3>
<p>Este algoritmo no está pensado para incluirse en un juego completo puesto que debe ser refinado. Sólo tenemos en cuenta la animación externa del personaje (desplazamiento y orientación). El algoritmo se olvida completamente de la animación interna. Si quieres un mejor resultado deberías incluirla (andar, detenerse, etc).</p>
<p>La rotación es brusca, lo ideal sería aplicarla poco a poco de forma que el personaje se girase suavemente. Para hacerlo deberíamos dividir la rotación en partes y aplicar una en cada frame.</p>
<h3>Referencias</h3>
<p>Seguramente quieras consultar fuentes mucho más fiables que yo:</p>
<ul>
<li><em>Game Engine Architecture (Jason Gregory)</em>: libro que cubre todos los aspectos a la hora de desarrollar un motor de juego. Contiene una sección de matemáticas muy bien explicada.</li>
<li><a class="text-contentLink text-xl" href="http://en.wikipedia.org/wiki/Lerp_%28computing%29"><em>LERP (Wikipedia)</em></a></li>
<li><a class="text-contentLink text-xl" href="http://www.cprogramming.com/tutorial/3d/quaternions.html"><em>Quaternios (Confuted)</em></a>: si esto de los cuaternios te ha sonado a chino te recomiendo que consultes este artículo en el que se hace una pequeña introducción.</li>
<li><a class="text-contentLink text-xl" href="http://www.ogre3d.org/docs/api/html/index.html"><em>Documentación oficial de Ogre</em></a>: para obtener más detalles sobre las clases y los métodos empleados.</li>
</ul></article></main></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metadata":{"path":"content/post/2010-12-26-movimiento-relativo-a-la-camara.mdx","title":"Movimiento relativo a la cámara","date":"2010-12-26T12:52:13.000Z","categories":["Games development"],"series":null,"description":null,"slug":"movimiento-relativo-a-la-camara","readingTime":"6 min read","draft":false,"disableComments":false,"keywords":[],"banner":null},"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    img: \"img\",\n    p: \"p\",\n    strong: \"strong\",\n    h3: \"h3\",\n    em: \"em\",\n    div: \"div\",\n    pre: \"pre\",\n    code: \"code\",\n    ul: \"ul\",\n    li: \"li\",\n    a: \"a\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.img, {\n      src: \"/img/wp/movimiento-camara.webp\",\n      alt: \"movimiento-camara.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"En la mayoría de videojuegos en tercera persona, \", _jsx(_components.strong, {\n        children: \"la dirección hacia la que se mueve el personaje depende de la orientación de la cámara\"\n      }), \". A pesar de que Sion Tower es un tower defense, controlamos a un personaje en tercera persona y, por tanto, debía incorporar este sistema. Estos días he estado exprimiendo los sesos para implementar dicho movimiento. ¡Por fin! Tras decenas de diagramas con vectores, ángulos y sistemas de coordenadas, lo he conseguido. En este artículo \", _jsx(_components.strong, {\n        children: \"explico un sencillo algoritmo para conseguirlo\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"¿Qué queremos conseguir?\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"El siguiente diagrama muestra el \", _jsx(_components.strong, {\n        children: \"sistema de coordenadas de Ogre\"\n      }), \". Imaginad que nuestro personaje se encuentra en el origen \", _jsx(_components.em, {\n        children: \"p = (0, 0, 0)\"\n      }), \" y que la cámara está en el \", _jsx(_components.em, {\n        children: \"c = (0, 0, 50)\"\n      }), \" mirando hacia el origen. Nuestras teclas de movimiento son las clásicas: WASD. Al pulsar W el personaje debe moverse en la dirección negativa del eje Z, en cambio, si pulsamos D deberá hacerlo en la dirección positiva del eje X.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"En cambio, si la cámara se situase en \", _jsx(_components.em, {\n        children: \"c = (50, 0, 0)\"\n      }), \" mirando a \", _jsx(_components.em, {\n        children: \"(0, 0, 0)\"\n      }), \" las teclas no tendrían el mismo efecto en términos absolutos, aunque se mantiene idéntico si tomamos como punto de referencia a la cámara. Si pulsamos W el personaje se desplazará en la dirección negativa del eje X. En el caso de que pulsemos D, el personaje se dirigirá en la dirección negativa del eje Z.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/coordenadas.webp\",\n      alt: \"coordenadas.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Por supuesto, \", _jsx(_components.strong, {\n        children: \"el personaje deberá girarse\"\n      }), \" para mirar hacia la dirección del desplazamiento. A continuación, detallamos la manera de implementar este sistema de movimiento.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Algoritmo: objetos implicados\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Este pequeño algoritmo está orientado al motor de renderizado Ogre3D y la biblioteca de dispositivos de entrada OIS aunque su filosofía es válida para otras herramientas. Lo ideal sería utilizar clases para el personaje y otros elementos aunque, en esta ocasión, he preferido no hacerlo en favor de la simplicidad del ejemplo.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Partimos de los siguientes objetos:\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"Ogre::SceneNode* nodoPersonaje; // Nodo que representa al personaje\\nOgre::Vector3 direccionObjetivo; // Relativa a la cámara\\nOgre::Vector3 direccionActual; // Relativa a la cámara\\nOgre::Vector3 velocidad; // Velocidad del personaje\\nbool andando; // true si el personaje se está desplazando\\nOIS::Keyboard* teclado; // Teclado para controlar al personaje\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Algoritmo: desplazamiento del personaje\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"En cada frame debemos \", _jsx(_components.strong, {\n        children: \"tomar la dirección de la cámara\"\n      }), \" y quedarnos con su componente x y z ya que nos movemos en el plano. Esa será nuestra dirección \", _jsx(_components.em, {\n        children: \"\\\"hacia delante\\\"\"\n      }), \". Es muy sencillo obtener la dirección \\\"\", _jsx(_components.em, {\n        children: \"hacia la derecha\\\"\"\n      }), \", simplemente intercambiamos las componentes x y z cambiándole el signo a la z de \", _jsx(_components.em, {\n        children: \"\\\"hacia delante\\\"\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"La dirección objetivo\"\n      }), \" de este frame se puede calcular consultando las \", _jsx(_components.strong, {\n        children: \"pulsaciones de las teclas\"\n      }), \" y \", _jsx(_components.strong, {\n        children: \"combinando los dos vectores\"\n      }), \" anteriores utilizando sumas o restas. Nos podremos mover en 8 direcciones distintas. Por ejemplo, si deseamos dirigirnos hacia atrás a la izquierda tendremos: \", _jsx(_components.em, {\n        children: \"direccionObjetivo = -delante – derecha\"\n      }), \". Finalmente, \", _jsx(_components.strong, {\n        children: \"la dirección objetivo debe ser normalizada\"\n      }), \", es decir, que el módulo del vector sea igual a 1. Esto es muy importante si no queremos que la velocidad del personaje se vea alterada. Finalmente, aplicamos el desplazamiento teniendo en cuenta la velocidad, la dirección y el tiempo en milisegundos desde el último frame. Esta técnica se conoce como \", _jsx(_components.strong, {\n        children: \"LERP\"\n      }), \" (Linear Interpolation).\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Algoritmo: orientación del personaje\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Sólo nos queda corregir la orientación del personaje para que mire hacia la dirección en la que se desplaza. Ogre pone a nuestra disposición el método \", _jsx(_components.em, {\n        children: \"Vector3::getRotationTo\"\n      }), \" que, dado un vector nos devuelve el cuaternio a aplicar de forma que tras la rotación quede alineado con el segundo. \", _jsx(_components.strong, {\n        children: \"Los cuaternios se utilizan para representar rotaciones\"\n      }), \" en el espacio y están compuestos por un ángulo y un eje (en este caso el y). Si multiplicamos la rotación necesaria por la que ya posee el nodo del personaje, éste mirará hacia donde deseamos. Es importante el orden de los operadores ya que el producto de cuaternios no es conmutativo.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Algoritmo: código completo\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"He aquí el código completo:\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"using namespace Ogre;\\n\\nvoid EstadoJuego::actualizarPersonaje(Ogre::Real deltaT) {\\n    // Tomamos la dirección de la cámara\\n    Vector3 delante = camara-\u0026gt;getDirection();\\n    delante.y = 0;\\n\\n    // Vector relativo a la cámara, ortogonal hacia su derecha\\n    Vector3 derecha(-delante.z, 0, delante.x);\\n\\n    // Calculamos la dirección objetivo en función de la pulsación de las\\n    // teclas.\\n    if (teclado-\u0026gt;isKeyDown(OIS::KC_W) \u0026amp;\u0026amp; teclado-\u0026gt;isKeyDown(OIS::KC_D)) {\\n        direccionObjetivo = delante + derecha;\\n        andando = true;\\n    }\\n    else if (teclado-\u0026gt;isKeyDown(OIS::KC_W) \u0026amp;\u0026amp; teclado-\u0026gt;isKeyDown(OIS::KC_A)) {\\n        direccionObjetivo = delante - derecha;\\n        andando = true;\\n    }\\n    else if (teclado-\u0026gt;isKeyDown(OIS::KC_S) \u0026amp;\u0026amp; teclado-\u0026gt;isKeyDown(OIS::KC_D)) {\\n        direccionObjetivo = -delante + derecha;\\n        andando = true;\\n    }\\n    else if (teclado-\u0026gt;isKeyDown(OIS::KC_S) \u0026amp;\u0026amp; teclado-\u0026gt;isKeyDown(OIS::KC_A)) {\\n        direccionObjetivo = -delante - derecha;\\n        andando = true;\\n    }\\n    else if (teclado-\u0026gt;isKeyDown(OIS::KC_W)) {\\n        direccionObjetivo = delante;\\n        andando = true;\\n    }\\n    else if (teclado-\u0026gt;isKeyDown(OIS::KC_S)) {\\n        direccionObjetivo = -delante;\\n        andando = true;\\n    }\\n    else if (teclado-\u0026gt;isKeyDown(OIS::KC_D)) {\\n        direccionObjetivo = derecha;\\n        andando = true;\\n    }\\n    else if (teclado-\u0026gt;isKeyDown(OIS::KC_A)){\\n        direccionObjetivo = -derecha;\\n        andando = true;\\n    }\\n    else\\n        andando = false;\\n\\n    // Normalizamos el vector direccion\\n    direccionObjetivo.normalise();\\n\\n    // Si debemos desplazarnos, aplicamos la traslación y calculamos la\\n    // rotación a aplicar\\n    if (andando) {\\n        nodoPersonaje-\u0026gt;translate(velocidad * direccionObjetivo * deltaT,\\n                                 Node::TS_WORLD);\\n        if (direccionObjetivo != direccionActual) {\\n            Quaternion rotacion = direccionActual.getRotationTo(direccionObjetivo,\\n                                                                Vector3(0, 1, 0));\\n            Quaternion rotacionActual = nodoPersonaje-\u0026gt;getOrientation()\\n            nodoPersonaje-\u0026gt;setOrientation(orientacion * rotacionActual);\\n            direccionActual = direccionObjetivo;\\n        }\\n    }\\n}\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Posibles mejoras\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Este algoritmo no está pensado para incluirse en un juego completo puesto que debe ser refinado. Sólo tenemos en cuenta la animación externa del personaje (desplazamiento y orientación). El algoritmo se olvida completamente de la animación interna. Si quieres un mejor resultado deberías incluirla (andar, detenerse, etc).\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"La rotación es brusca, lo ideal sería aplicarla poco a poco de forma que el personaje se girase suavemente. Para hacerlo deberíamos dividir la rotación en partes y aplicar una en cada frame.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Referencias\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Seguramente quieras consultar fuentes mucho más fiables que yo:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.em, {\n          children: \"Game Engine Architecture (Jason Gregory)\"\n        }), \": libro que cubre todos los aspectos a la hora de desarrollar un motor de juego. Contiene una sección de matemáticas muy bien explicada.\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"http://en.wikipedia.org/wiki/Lerp_%28computing%29\",\n          children: _jsx(_components.em, {\n            children: \"LERP (Wikipedia)\"\n          })\n        })\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"http://www.cprogramming.com/tutorial/3d/quaternions.html\",\n          children: _jsx(_components.em, {\n            children: \"Quaternios (Confuted)\"\n          })\n        }), \": si esto de los cuaternios te ha sonado a chino te recomiendo que consultes este artículo en el que se hace una pequeña introducción.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"http://www.ogre3d.org/docs/api/html/index.html\",\n          children: _jsx(_components.em, {\n            children: \"Documentación oficial de Ogre\"\n          })\n        }), \": para obtener más detalles sobre las clases y los métodos empleados.\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","scope":{}},"series":null},"__N_SSG":true},"page":"/[slug]","query":{"slug":"movimiento-relativo-a-la-camara"},"buildId":"5YKEeJrSBspihiTxQqQYZ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>