<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
	<meta name="generator" content="Hugo 0.94.2" />
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1"/>

  <title>David Saltares &middot; Engineering Leadership &amp; Software Development</title>

  
  <link rel="stylesheet" href="../../css/poole.css">
  <link rel="stylesheet" href="../../css/hyde.css">
  <link rel="stylesheet" href="../../css/poole-overrides.css">
  <link rel="stylesheet" href="../../css/hyde-overrides.css">
  <link rel="stylesheet" href="../../css/hyde-x.css">
  <link rel="stylesheet" href="../../css/highlight/github-dark-dimmed.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../touch-icon-144-precomposed.png">
  <link href="../../img/favicon.png" rel="icon">

  
  
  
  <link href="%7balternate%20%7bRSS%20application/rss&#43;xml%20%20index%20alternate%20%20false%20false%20true%20false%20false%200%7d%20/index.xml%20https://saltares.com/index.xml%7d" rel="alternate" type="application/rss+xml" title="David Saltares &middot; David Saltares" />

  <meta name="description" content="I am David and I write about engineering leadership, remote teams, software development and games development.">
  <meta name="keywords" content="">
  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-4440744-3', 'auto');
    ga('send', 'pageview');
  </script>
  

  

  
  <link rel="canonical" href="https://saltares.com/" itemprop="url" />
</head>
<body>
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="../../"><img src="../../img/profile.jpg"
             alt="profile-picture" id="profile-img" title="David Saltares"></a>
      <h1><a href="../../">David Saltares</a></h1>
      <p class="lead">Engineering Leadership &amp; Software Development</p>
      <div class="subscribe"><a href="https://tinyletter.com/dsaltares/">✉️ Subscribe</a></div>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="../../">Blog</a></li>
      
      <li class="sidebar-nav-item"><a href="../../about">About</a></li>
      
      <li class="sidebar-nav-item"><a href="../../apps-tools">Apps &amp; Tools</a></li>
      
      <li class="sidebar-nav-item"><a href="../../game-jams">Game Jams</a></li>
      
      <li class="sidebar-nav-item"><a href="../../games">Games</a></li>
      
      <li class="sidebar-nav-item"><a href="../../libgdx-cross-platform-game-development-cookbook">Libgdx Cookbook</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a aria-label="Github profile" href="http://github.com/dsaltares"><i class="fa fa-github-square fa-2x"></i></a>
      
      
      <a aria-label="LinkedIn profile" href="https://www.linkedin.com/in/davidsaltares"><i class="fa fa-linkedin-square fa-2x"></i></a>
      
      
      <a aria-label="Twitter profile" href="http://twitter.com/d_saltares"><i class="fa fa-twitter-square fa-2x"></i></a>
      
      <a aria-label="RSS" href="../../index.xml" type="application/rss+xml"><i class="fa fa-rss-square fa-2x"></i></a>
      </li>
    </ul>

    

    <div class="copyright">
      <p>&copy; 2022 David Saltares.</p>
    </div>
  </div>
</div>


<div class="content container">
  <div class="posts">
    
    
    <div class="post">
      <h1 class="post-title">
        <a href="https://saltares.com/games/colisiones-iv-tests-de-colision/">Colisiones IV: Tests de colisión</a>
      </h1>
      <span class="post-date">Feb 15, 2011 &middot; 7 minute read &middot; <a href="https://saltares.com/games/colisiones-iv-tests-de-colision/#disqus_thread">Comments</a>
      
      <br/>
      <a class="label" href="../../categories/games-development">Games development</a>
      </span>
      
      <p>
  <img src="../../img/wp/colisiones-4.png" alt="colisiones-4.png">

</p>
<p>Entregas:</p>
<ul>
<li><a href="../../proyectos/pfc/sion-tower/colisiones-i-introduccion-requisitos-y-alternativas/">Colisiones I: Introducción, requisitos y alternativas</a></li>
<li><a href="../../proyectos/pfc/sion-tower/colisiones-ii-diseno-general-de-stc/">Colisiones II: Diseño general de STC</a></li>
<li><a href="../../proyectos/pfc/sion-tower/colisiones-iii-shape-y-collision-dispatching/">Colisiones III: Shape y Collision Dispatching</a></li>
<li><em>Colisiones IV: Tests de colisión</em></li>
</ul>
<p>En la cuarta entrega de la serie de artículos de documentación sobre el <strong>sistema de detección de colisiones de Sion Tower</strong> (STC) trataremos en profundidad los <strong>tests de colisión</strong>. Hasta ahora habíamos visto como funciona la clase abstracta Shape y sus implementaciones así como el Collision Dispatching. Este texto no pretende demostrar la validez de los algoritmos expuestos por la mediana complejidad que algunos entrañan, para una explicación más extensa sugiero acudir a las referencias contenidas en la sección de bibliografía.</p>
<p>Para cada test se ofrece una breve explicación, un diagrama aclaratorio y el algoritmo en C++ utilizando Ogre3D y las clases que hemos visto hasta el momento.</p>
<h3 id="teorema-del-plano-de-separación">Teorema del plano de separación</h3>
<p>El <strong>Teorema del eje de separación</strong> (<a href="http://en.wikipedia.org/wiki/Separating_axis_theorem">separating axis theorem</a>) resulta extremadamente útil en la detección de colisiones. Este teorema asegura que dados dos objetos convexos en un plano 2D existe una línea sobre la cual, las proyecciones de los dos objetos no se solapan si y sólo si los objetos son disjuntos (no tienen puntos en común). Esta línea se conoce como eje de separación. En un espacio tridimensional el eje de separación se convierte en un plano de separación. El siguiente diagrama ilustra el teorema.</p>
<p>
  <img src="../../img/wp/separatin-axis.png" alt="separatin-axis.png">

</p>
<p>En muchos tests <strong>buscaremos el plano de separación</strong>, puede que existan varios pero en el momento que encontremos el primero podremos asegurar que los objetos no colisionan (suponiendo que sus formas son convexas). En cualquier videojuego lo normal es que dos objetos cualesquiera no colisionen, por lo que es más eficiente descartar posibles intersecciones cuanto antes. Buscando planos de separación.</p>
<h3 id="test-sphere-sphere">Test Sphere-Sphere</h3>
<p>El test entre dos esferas es el más sencillo y rápido de todos. Basta con comprobar si la distancia entre los centros de ambas esferas es menor que la suma de sus radios, en tal caso existiría colisión.</p>
<p>
  <img src="../../img/wp/test-sphere-sphere.png" alt="test-sphere-sphere.png">

</p>
<p>Para calcular la distancia entre dos puntos es necesario una raíz cuadrada pero éstas son extremadamente caras. Podemos comparar la distancia al cuadrado con el cuadrado de la suma de los radios, una expresión equivalente y de mayor eficiencia.</p>
<pre tabindex="0"><code>bool Shape::getCollisionSphereSphere(Shape* shapeA, Shape* shapeB) {
    // Hacemos la conversión (estamos seguros de que son esferas)
    Sphere* sphereA = static_cast&lt;sphere *&gt;(shapeA);
    Sphere* sphereB = static_cast&lt;/sphere&gt;&lt;sphere *&gt;(shapeB);

    // Hacemos el test
    Ogre::Vector3 s = sphereA-&gt;getCenter() - sphereB-&gt;getCenter();
    Ogre::Real totalRadius = sphereA-&gt;getRadius() + sphereB-&gt;getRadius();

    return (s.squaredLength() &lt; = totalRadius * totalRadius);
}
</code></pre><h3 id="test-aabb-aabb">Test AABB-AABB</h3>
<p>En la intersección entre cajas alineadas con los ejes emplearemos el teorema del plano de separación. Proyectamos las cajas sobre cada uno de los tres ejes y si algunas de las proyecciones no se solapan podremos asegurar que no existe colisión entre las AABB. El siguiente diagrama ilustra el test.</p>
<p>
  <img src="../../img/wp/test-aabb-aabb.png" alt="test-aabb-aabb.png">

</p>
<pre tabindex="0"><code>bool Shape::getCollisionAABBAABB(Shape* shapeA, Shape* shapeB) {
    // Hacemos la conversión (estamos seguros de que son AABBs)
    AxisAlignedBox* aabb1= static_cast&lt;axisalignedbox *&gt;(shapeA);
    AxisAlignedBox* aabb2 = static_cast&lt;/axisalignedbox&gt;&lt;axisalignedbox *&gt;(shapeB);

    // Hacemos el test
    return (aabb1-&gt;getMaxPos().x &gt; aabb2-&gt;getMinPos().x &amp;&amp;
            aabb1-&gt;getMinPos().x &lt; aabb2-&gt;getMaxPos().x &amp;&amp;
            aabb1-&gt;getMaxPos().y &gt; aabb2-&gt;getMinPos().y &amp;&amp;
            aabb1-&gt;getMinPos().y &lt; aabb2-&gt;getMaxPos().y &amp;&amp;
            aabb1-&gt;getMaxPos().z &gt; aabb2-&gt;getMinPos().z &amp;&amp;
            aabb1-&gt;getMinPos().z &lt; aabb2-&gt;getMaxPos().z);
}
</code></pre><h3 id="test-plane-plane">Test Plane-Plane</h3>
<p>Los planos son infinitos por lo que la única situación en la que dos planos no colisionan es cuando estos son paralelos y no están a la misma distancia del origen. La orientación de los planos está definida por su vector normal. Si las dos normales son paralelas y la distancia con respecto al origen no coincide podremos asegurar que los planos no colisionan. Dos vectores son paralelos si su producto escalar es igual a 1.</p>
<p>
  <img src="../../img/wp/test-plane-plane.png" alt="test-plane-plane.png">

</p>
<pre tabindex="0"><code>bool Shape::getCollisionPlanePlane(Shape* shapeA, Shape* shapeB) {
    // Hacemos la conversión (estamos seguros de que son Planes)
    Plane* planeA = static_cast&lt;plane *&gt;(shapeA);
    Plane* planeB = static_cast&lt;/plane&gt;&lt;plane *&gt;(shapeB);

    // Hacemos el test
    Ogre::Vector3 normalA = planeA-&gt;getNormal().normalisedCopy();
    Ogre::Vector3 normalB = planeB-&gt;getNormal().normalisedCopy();
    return normalA.dotProduct(normalB) != 1;
}
</code></pre><h3 id="test-sphere-aabb">Test Sphere-AABB</h3>
<p>En este test se pueden producir dos casos en los que existe intersección entre los objetos. El primero se da cuando el centro de la esfera está contenida en el AABB mientras que el segundo tiene lugar cuando el centro está fuera de la caja pero existe intersección (el diagrama ilustra el segundo caso). En primer lugar comprobamos si el centro de la esfera está dentro de la caja. Posteriormente recorremos los vértices del AABB y elegimos el más cercano al centro de la esfera. Si la distancia entre ambos es menor que el radio de la esfera las dos formas colisionan.</p>
<p>
  <img src="../../img/wp/test-sphere-aabb.png" alt="test-sphere-aabb.png">

</p>
<p>De nuevo, utilizamos el cuadrado de la distancia para conseguir una mayor eficiencia.</p>
<pre tabindex="0"><code>bool Shape::getCollisionSphereAABB(Shape* shapeA, Shape* shapeB) {
    // Hacemos la conversión (estamos seguros de que A es Sphere y B es AABB)
    Sphere* sphere;
    AxisAlignedBox* aabb;
    if (shapeA-&gt;getType() == SPHERE) {
        sphere = static_cast&lt;sphere *&gt;(shapeA);
        aabb = static_cast&lt;axisalignedbox *&gt;(shapeB);
    } else {
        sphere = static_cast&lt;sphere *&gt;(shapeB);
        aabb = static_cast&lt;axisalignedbox *&gt;(shapeA);
    }

    // Hacemos el test
    Ogre::Real s = 0;
    Ogre::Real d = 0;
    Ogre::Vector3 center = sphere-&gt;getCenter();
    Ogre::Vector3 minPos = aabb-&gt;getMinPos();
    Ogre::Vector3 maxPos = aabb-&gt;getMaxPos();

    // Comprobamos si el centro de la esfera está dentro del AABB
    bool centerInsideAABB = (center.x &lt; = maxPos.x &amp;&amp;
                             center.x &gt;= minPos.x &amp;&amp;
                             center.y &lt; = maxPos.y &amp;&amp;
                             center.y &gt;= minPos.y &amp;&amp;
                             center.z &lt; = maxPos.z &amp;&amp;
                             center.z &gt;= minPos.z);

    if (centerInsideAABB)
        return true;

    // Comprobamos si la esfera y el AABB se intersectan
    for (int i = 0; i &lt; 3; ++i) {
        if (sphere-&gt;getCenter()[i] &lt; aabb-&gt;getMinPos()[i]) {
            s = sphere-&gt;getCenter()[i] - aabb-&gt;getMinPos()[i];
            d += s * s;
        } else if (sphere-&gt;getCenter()[i] &gt; aabb-&gt;getMaxPos()[i]) {
            s = sphere-&gt;getCenter()[i] - aabb-&gt;getMaxPos()[i];
            d += s * s;
        }
    }

    return (d &lt; = sphere-&gt;getRadius() * sphere-&gt;getRadius());
}
</code></pre><h3 id="test-sphere-plane">Test Sphere-Plane</h3>
<p>Comprobar si una esfera colisiona con un plano es tan sencillo como obtener la distancia entre ambos y compararla con el radio de la esfera como hemos hecho en otras ocasiones. La distancia entre el centro y el punto que conocemos del plano no es la distancia real entre ambas formas. Para calcular la distancia real tendremos que proyectar el vector p-c (punto del plano – centro de la esfera) sobre la normal del plano.</p>
<p>
  <img src="../../img/wp/test-sphere-plane.png" alt="test-sphere-plane.png">

</p>
<p>Sólo nos es necesario el cuadrado de la distancia y lo comprobaremos con el cuadrado del radio (para evitarnos utilizar una raíz cuadrada).</p>
<pre tabindex="0"><code>bool Shape::getCollisionPlaneSphere(Shape* shapeA, Shape* shapeB) {
    // Hacemos la conversión (estamos seguros de que A es Plane y B es Sphere)
    Plane* plane;
    Sphere* sphere;
    if (shapeA-&gt;getType() == PLANE) {
        plane = static_cast&lt;plane *&gt;(shapeA);
        sphere = static_cast&lt;sphere *&gt;(shapeB);
    } else {
        plane = static_cast&lt;plane *&gt;(shapeB);
        sphere = static_cast&lt;sphere *&gt;(shapeA);
    }

    // Hacemos el test

    // Distancia del centro de la esfera al plano
    Ogre::Vector3 v = sphere-&gt;getCenter() - plane-&gt;getPosition();
    Ogre::Vector3 n = plane-&gt;getNormal().normalisedCopy();
    Ogre::Real d = abs(n.dotProduct(v));

    // Si d &lt; = radio, hay colisión
    return d &lt;= sphere-&gt;getRadius();
}
</code></pre><h3 id="test-aabb-plane">Test AABB-Plane</h3>
<p>En el test entre AABB y plano calculamos el vértice más lejano y el más cercano al plano (pmin y pmax respectivamente). Si cada punto está a un lado distinto del plano podemos asegurar que ambas formas colisionan.</p>
<p>
  <img src="../../img/wp/test-plane-aabb.png" alt="test-plane-aabb.png">

</p>
<pre tabindex="0"><code>bool Shape::getCollisionPlaneAABB(Shape* shapeA, Shape* shapeB) {
    // Hacemos la conversión (estamos seguros de que A es Plane y B es AABB)
    Plane* plane;
    AxisAlignedBox* aabb;
    if (shapeA-&gt;getType() == PLANE) {
        plane = static_cast&lt;plane *&gt;(shapeA);
        aabb = static_cast&lt;axisalignedbox *&gt;(shapeB);
    } else {
        plane = static_cast&lt;plane *&gt;(shapeB);
        aabb = static_cast&lt;axisalignedbox *&gt;(shapeA);
    }

    // Hacemos el test
    Ogre::Vector3 p;
    Ogre::Vector3 n;

    for (int i = 0; i &lt; 3; ++i) {
        if (plane-&gt;getNormal()[i] &gt;= 0) {
            p[i] = aabb-&gt;getMaxPos()[i];
            n[i] = aabb-&gt;getMinPos()[i];
        } else {
            p[i] = aabb-&gt;getMaxPos()[i];
            n[i] = aabb-&gt;getMinPos()[i];
        }
    }

    // Si p está en un lado diferente del plano que n, hay intersección
    Ogre::Real d1 = plane-&gt;getNormal().dotProduct(p - plane-&gt;getPosition());
    Ogre::Real d2 = plane-&gt;getNormal().dotProduct(n - plane-&gt;getPosition());

    return ((d1 &lt; = 0 &amp;&amp; d2 &gt;= 0) || (d1 &gt;= 0 &amp;&amp; d2 &lt; = 0));
}
</code></pre><h3 id="bibliografía">Bibliografía</h3>
<p>Como podéis comprobar, hay un poco más de fundamento detrás de estos tests de lo que se ha explicado en la secciones anteriores. Para obtener más información sobre este interesante tema, recomiendo las siguientes lecturas (todo en inglés):</p>
<ul>
<li><a href="http://realtimecollisiondetection.net/">Real Time Collision Detection</a> (Christer Ericson ): excepcional libro que cubre todo lo relacionado sobre la detección de colisiones en 3D escrito por un trabajador de Sony Computer Entertainment America.</li>
<li><a href="http://www.gamasutra.com/view/feature/3383/simple_intersection_tests_for_games.php">Gamasutra &ldquo;Simple intersection tests for games&rdquo;</a> (Miguel Gomez): repaso por varios tests de intersección entre distintos tipos de formas (cubre cuerpos en movimiento).</li>
<li><a href="http://www.gamasutra.com/view/feature/3190/advanced_collision_detection_.php">Gamasutra &ldquo;Advanced collision detection techniques&rdquo;</a> (Nick Bobic): técnicas de detección de colisiones, particionado del espacio y otras optimizaciones.</li>
<li><a href="http://www.metanetsoftware.com/technique/tutorialA.html">Metanet software &ldquo;Collision detection and response&rdquo;</a>: explicación teórica sobre la detección de colisione. Cuenta con ejemplos gráficos interactivos para ilustrar cada concepto. Me la recomendó el compañero José Tomás Tocino.</li>
</ul>
<p>En el siguiente artículo lo dedicaremos a las clases Body y CollisionManager del sistema de detección de colisiones de Sion Tower.</p>

      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="https://saltares.com/games/web-estatica-en-red-iris/">Web estática en Red Iris</a>
      </h1>
      <span class="post-date">Feb 14, 2011 &middot; 1 minute read &middot; <a href="https://saltares.com/games/web-estatica-en-red-iris/#disqus_thread">Comments</a>
      
      <br/>
      <a class="label" href="../../categories/games-development">Games development</a>
      </span>
      
      <p><a href="http://cusl5-iberogre.forja.rediris.es/">
  <img src="../../img/wp/web-estatica-iberogre-214x300.png" alt="web-estatica-iberogre-214x300.png">

</a></p>
<p><strong>La Forja de Red Iris proporciona a cada proyecto un espacio</strong> para colgar una web estática sencilla. Es una tontería no aprovechar dicho espacio ya que Red Iris cuenta con un indexado en buscadores excelente. Simplemente <a href="http://cusl5-iberogre.forja.rediris.es/">he colgado un panel</a> explicando en qué consiste mi proyecto junto con enlaces a otros medios (wiki, blog, forja y Twitter).</p>
<p>No es nada del otro mundo ya que mis habilidades de diseño tienden a cero pero creo que será s<strong>uficiente para ampliar un poco más la difusión del proyecto</strong>. Cualquiera que llegue a esa página podrá acceder de forma sencilla a los focos en los hay más actividad. Creo que es una buena idea y algo que debería haber hecho hace cierto tiempo.</p>

      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="https://saltares.com/hobbies/mas-alla-de-la-vida/">Más allá de la vida</a>
      </h1>
      <span class="post-date">Feb 13, 2011 &middot; 3 minute read &middot; <a href="https://saltares.com/hobbies/mas-alla-de-la-vida/#disqus_thread">Comments</a>
      
      <br/>
      <a class="label" href="../../categories/hobbies">Hobbies</a>
      </span>
      
      <p>
  <img src="../../img/wp/hereafter.jpg" alt="hereafter.jpg">

</p>
<p>Como queda poco para los Oscar <strong>era buen momento para ir a ver las películas nominada</strong>s. No obstante, en mi cine habitual suelen retirar de cartelera el buen material con sorprendente rapidez dejando la carroña típica. Eso y el hecho de tener que elegir la intersección de los gustos entre los miembros del grupo hizo que acabásemos yendo a <a href="http://www.imdb.es/title/tt1212419/"><strong>Más allá de la vida</strong></a>, dirigida por el veterano <a href="http://www.imdb.es/name/nm0000142/">Clint Eastwood</a> y nominada por los mejores efectos visuales. Craso error.</p>
<p><em>Más allá de la vida</em> cuenta las historias de <strong>tres protagonistas que acaban encontrándose a través de la famosa técnica del calzador</strong> en el último momento. George Logan (<a href="http://www.imdb.es/name/nm0000354/">Matt Damon</a>) es un parapsicólogo de San Francisco que contacta con los familiares difuntos de aquellos que toca. Considera que su habilidad es una maldición y le impide llevar una vida normal por lo que lo deja definitivamente. Marie (<a href="http://www.imdb.es/name/nm0208426/">Cécile de France</a>) es una periodista parisina que pasó varios minutos técnicamente muerta tras un tsunami y el contacto con el más allá le cambia para siempre. Marcos (<a href="http://www.imdb.es/name/nm3727999/">Frankie McLaren</a>) es un niño londinense cuya madre es drogadicta y pierde a su hermano gemelo en un accidente de tráfico.</p>
<p>Estaremos de acuerdo en que hay diversos tipos de cine, por ejemplo, algunas películas buscan entretener a través el humor o la acción sin que nos hagan pensar demasiado. En cambio, otras pretenden evocar sentimientos o inducirnos a la meditación. Comprendo perfectamente que las últimas sean más duras de seguir y requieran esfuerzo extra por parte del espectador. <em>Más allá de la vida</em> busca que reflexionemos sobre la vida y la muerte aunque <strong>se muestra terriblemente torpe</strong> es ese aspecto. Es lenta, <strong>dolorosamente lenta</strong> y para colmo sales de la sala con la sensación de que no te han contado nada.</p>
<p>A su favor he de decir que algunas escenas están bien llevadas, son creíbles y su carga dramática nos alcanza. No deben confundirse porque en absoluto representa la tónica general. En la mayor parte de los casos <strong>recurre al tópico fácil</strong> sin tratar de ir más allá (menudo juego de palabras que me he sacado de la manga). El <strong>inexpresivo Matt Damon</strong> no pega ni con cola en un largometraje dramático como este. Nadie puede negar que es un actor estupendo para la trilogía Bourne pero en este caso no consigue conectar con el personaje ni con la audiencia, a mí me ha dejado completamente indiferente.</p>
<p>Creo que puedo resumir de forma acertada mi reseña diciendo que la película son <strong>dos horas que se viven como cuatro</strong>. Tiene un único objetivo en el que fracasa estrepitosamente. Imagino que la nominación a los mejores efectos visuales corresponden a los primeros cinco minutos de película en los que aparece el tsunami porque el resto no tiene nada. Debe estar muy malita la cosa en Hollywood para que Más allá de la vida aparezca en esta categoría. <strong>Si pueden evitarla, no lo duden, háganlo</strong>.</p>

      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="https://saltares.com/games/sion-tower-video-de-colisiones-y-audio-3d/">Sion Tower, vídeo de colisiones y audio 3D</a>
      </h1>
      <span class="post-date">Feb 11, 2011 &middot; 1 minute read &middot; <a href="https://saltares.com/games/sion-tower-video-de-colisiones-y-audio-3d/#disqus_thread">Comments</a>
      
      <br/>
      <a class="label" href="../../categories/games-development">Games development</a>
      </span>
      
      <div
  style="position: relative; padding-bottom: 62.5%; height: 0; margin-bottom: 1em;">
  <iframe
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
    src="https://www.youtube.com/embed/jK32IioGmGk"
    frameborder="0"
    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen
  >
  </iframe>
</div>

<p>Como una imagen vale más que mil palabras he grabado este sencillo vídeo en el que se muestran tanto el sistema de detección de colisiones como la reproducción de audio 3D de Sion Tower. Estas semanas pienso trabajar duro en la carga del escenario a partir de un fichero DotScene, será interesante grabar otro vídeo dentro de cierto tiempo para comprobar la mejora.</p>

      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="https://saltares.com/games/colisiones-iii-shape-y-collision-dispatching/">Colisiones III: Shape y Collision Dispatching</a>
      </h1>
      <span class="post-date">Feb 10, 2011 &middot; 6 minute read &middot; <a href="https://saltares.com/games/colisiones-iii-shape-y-collision-dispatching/#disqus_thread">Comments</a>
      
      <br/>
      <a class="label" href="../../categories/games-development">Games development</a>
      </span>
      
      <p>
  <img src="../../img/wp/colisiones-3.png" alt="colisiones-3.png">

</p>
<p>Entregas</p>
<ul>
<li><a href="../../proyectos/pfc/sion-tower/colisiones-i-introduccion-requisitos-y-alternativas/">Colisiones I: Introducción, requisitos y alternativas</a></li>
<li><a href="../../proyectos/pfc/sion-tower/colisiones-ii-diseno-general-de-stc/">Colisiones II: Diseño general de STC</a></li>
<li>_Colisiones III: Shape y Collision Dispatching _</li>
</ul>
<p>Comenzamos la tercera entrega de la serie de artículos sobre **STC, el sistema de detección de colisiones de Sion Tower. En esta ocasión vamos a entrar en detalle en **la clase <em>Shape</em>, la encargada de modelar los volúmenes colisionables básicos entre otras tareas. Los tests de colisión entre formas concretas también pertenecen a esta clase pero por su complejidad los dejaremos para el siguiente artículo.</p>
<h3 id="la-clase-shape">La clase Shape</h3>
<p><em>Shape</em> es una clase abstracta y como tal no puede instanciarse directamente por lo que otros objetos han de heredar de ella e implementar los métodos convenientes. <em>Shape</em> modela un volumen geométrico genérico colisionable y está pensada para que todas sus implementaciones sean tratadas de manera uniforme.</p>
<p>
  <img src="../../img/wp/shapes.png" alt="shapes.png">

</p>
<h3 id="collision-dispatching">Collision Dispatching</h3>
<p>La clase <em>Shape</em> dispone de un método estático <em>getCollision</em> que recibe dos punteros a <em>Shape</em> y devuelve verdadero o falso en función de si se ha producido o no intersección. Internamente cuenta con otros métodos estáticos para detectar colisiones entre formas concretas, por ejemplo: la intersección entre una esfera y un AABB.</p>
<pre tabindex="0"><code>class Shape {
public:

    ...

    static bool getCollision(Shape* shapeA, Shape* shapeB);

    ...

private:

    static bool getCollisionSphereSphere(Shape* shapeA, Shape* shapeB);
    static bool getCollisionAABBAABB(Shape* shapeA, Shape* shapeB);
    static bool getCollisionPlanePlane(Shape* shapeA, Shape* shapeB);
    static bool getCollisionSphereAABB(Shape* shapeA, Shape* shapeB);
    static bool getCollisionPlaneSphere(Shape* shapeA, Shape* shapeB);
    static bool getCollisionPlaneAABB(Shape* shapeA, Shape* shapeB);

};
</code></pre><p>El <strong>Collision Dispatching</strong> es la tarea de seleccionar el test de colisión apropiado a partir de dos formas cuyo tipo desconocemos. En principio se podría pensar en emplear muchos bloques <em>if</em> con <em>dynamic_cast</em> capturando posibles excepciones para aseguramos de que seleccionamos los tipos apropiados. No obstante, ese tipo de casting son operaciones extremadamente costosas que no podemos permitirnos en un punto tan crítico como este. Estuve mucho tiempo dándole vueltas hasta dar con un sistema seguro, sencillo y eficiente de <a href="http://en.wikibooks.org/wiki/C++_Programming/RTTI">RTTI</a>.</p>
<p>Es posible conocer la clase a la que pertenece una forma génerica incorporando un método virtual puro en <em>Shape</em>. Cada especialización está obligado a implementarlo, devolviendo un valor de un enumerado indicando su tipo.</p>
<pre tabindex="0"><code>class Shape {
public:

    ...

    enum Type {SPHERE = 1, AABB = 2, PLANE = 3};

    virtual int getType() const = 0;

    ...
};

class Sphere {
public:

    ...

    int getType() const {return SPHERE;};

    ...
};
</code></pre><p>Podemos tener una tabla estática que dados dos tipos de formas nos devuelva el método que efectúa el test de colisión entre ambas. En cada test de colisión se puede hacer un <em>static_cast</em> sin temor a encontrar con problemas ya que hemos comprobado el tipo con anterioridad. <em>static_cast</em> es mucho más rápido que <em>dynamic_cast</em> al no hacer comprobaciones.</p>
<p>No vamos a manejar punteros a función sino que <strong>haremos uso de las mágicas <em><a href="http://www.boost.org/doc/libs/1_45_0/doc/html/function.html">boost::function</a></em> y <a href="http://www.boost.org/doc/libs/1_45_0/libs/bind/bind.html"><em>boost:bind</em></a></strong>. Esto nos permitirá encapsular un método en un objeto y llamarlo posteriormente con el operador (). Si no conoces <a href="http://www.boost.org/">Boost</a> deberías echarle un ojo ya que muchos de sus componentes <strong>entrarán en el próximo estándar de C++</strong>. El año pasado, mi compañero José Tomás Tocino impartió un taller de esta biblioteca, podéis encontrar los materiales <a href="http://softwarelibre.uca.es:9001/redmine/repositories/show/taller-boost">aquí</a>. Para la tabla utilizaremos <em><a href="http://www.boost.org/doc/libs/1_38_0/doc/html/boost/unordered_map.html">boost::unordered_map</a></em>, similar a <a href="http://www.cppreference.com/wiki/container/map/start"><em>std::map</em></a> pero mucho más eficiente.</p>
<pre tabindex="0"><code>class Sphere:
public:
    ...

    static void configureCollisionDispatching();

    ...

private:

    ...

    typedef boost::function&lt;bool (Shape*, Shape*)&gt; CollisionCheckFunction;
    typedef boost::unordered_map&lt;int , boost::unordered_map&lt;int, CollisionCheckFunction&gt; &gt; CollisionDispatchTable;

    static CollisionDispatchTable  _collisionDispatcher;
};
</code></pre><p>El método <em>configureCollisionDispatching</em> se encarga de inicializar la tabla que asocia dos tipos con el método que implementa el test de colisión. Es necesario llamar a este método al comienzo de la aplicación aunque la clase <em>CollisionManager</em> ya lo hace por tí.</p>
<pre tabindex="0"><code>void Shape::configureCollisionDispatching() {
    _collisionDispatcher[SPHERE][SPHERE] = boost::bind(&amp;Shape::getCollisionSphereSphere, _1, _2);
    _collisionDispatcher[AABB][AABB] = boost::bind(&amp;Shape::getCollisionAABBAABB, _1, _2);
    _collisionDispatcher[PLANE][PLANE] = boost::bind(&amp;Shape::getCollisionPlanePlane, _1, _2);

    _collisionDispatcher[AABB][SPHERE] = boost::bind(&amp;Shape::getCollisionSphereAABB, _1, _2);
    _collisionDispatcher[AABB][PLANE] = boost::bind(&amp;Shape::getCollisionPlaneAABB, _1, _2);

    _collisionDispatcher[SPHERE][AABB] = boost::bind(&amp;Shape::getCollisionSphereAABB, _1, _2);
    _collisionDispatcher[SPHERE][PLANE] = boost::bind(&amp;Shape::getCollisionPlaneSphere, _1, _2);

    _collisionDispatcher[PLANE][AABB] = boost::bind(&amp;Shape::getCollisionPlaneAABB, _1, _2);
    _collisionDispatcher[PLANE][SPHERE] = boost::bind(&amp;Shape::getCollisionPlaneSphere, _1, _2);
}
</code></pre><p>De esta forma <strong>conseguimos un Collision Dispatching muy eficiente, cómodo y extensible</strong>.</p>
<h3 id="formas-disponibles">Formas disponibles</h3>
<p>Como habréis deducido por los diagramas de clases, la versión 0.1 de STC incorpora <strong>tres tipos de formas diferentes</strong>: <em>Sphere</em>, <em>Plane</em> y <em>AxisAlignedBox</em>. A continuación vemos las distintas formas junto a su representación interna y un pequeño diagrama.</p>
<p>La <strong>esfera</strong> se representa por un punto (centro) y un real (radio) tal y como se muestra en el siguiente esquema. Es una forma sencilla que permite tests de colisión muy rápidos. Es muy común representar formas utilizando cuatro números reales ya que los chips gráficos están optimizados para hacer operaciones en paralelo con cuatro datos.</p>
<p>
  <img src="../../img/wp/sphere.png" alt="sphere.png">

</p>
<p>El <strong>plano</strong> está formado por un punto (distancia con respecto al origen) y un vector (normal o perpendicular a sí mismo). Podéis visualizarlo en el siguiente esquema.</p>
<p>
  <img src="../../img/wp/plane.png" alt="plane.png">

</p>
<p>Existen dos tipos de cajas: las <em>AxisAlignedBox</em> y las <em>OrientedBox</em>. Las primeras, como indica su nombre, siempre están alineadas con los ejes y no presentan rotación. En cambio, las segundas son volúmenes rotados. Las cajas alineadas con los ejes las representamos a través de dos puntos (mínimo y máximo) como podéis ver en el siguiente diagrama.</p>
<p>
  <img src="../../img/wp/aabb.png" alt="aabb.png">

</p>
<p>Las <em>AABB</em> ofrecen tests de colisión sencillos pero <strong>no funcionan bien con objetos que rotan</strong>. Al no poder rotar la caja debemos reajustarla con la consecuente pérdida de precisión, en algunos casos inaceptable. El siguiente esquema muestra a un coche y su <em>AABB</em> de colisión en ambos estados: sin rotar y tras ser rotado.</p>
<p>
  <img src="../../img/wp/aabb-precission-loss.png" alt="aabb-precission-loss.png">

</p>
<h3 id="extendiendo-la-clase-shape">Extendiendo la clase Shape</h3>
<p>Para crear nuevas formas sólo hay que elegir la representación deseada e implementar los siguientes métodos virtuales puros de la clase <em>Shape</em>:</p>
<pre tabindex="0"><code>class Shape {
public:
  virtual int getType() const = 0;
  virtual void applyTransform(
    Shape* localShape,
    const Ogre::Vector3&amp; traslation = Ogre::Vector3::ZERO,
    const Ogre::Vector3&amp; scale = Ogre::Vector3::UNIT_SCALE,
    const Ogre::Quaternion&amp; orientation = Ogre::Quaternion::IDENTITY) = 0;
  virtual Shape* getTransformedCopy(
    const Ogre::Vector3&amp; traslation = Ogre::Vector3::ZERO,
    const Ogre::Vector3&amp; scale = Ogre::Vector3::UNIT_SCALE,
    const Ogre::Quaternion&amp; orientation = Ogre::Quaternion::IDENTITY) = 0;
};
</code></pre><p>El método <em>applyTransform</em> transforma la forma actual a partir de <em>localShape</em> incluyendo desplazamiento, escala y rotación. El método <em>getTransformedCopy</em> devuelve una copia de sí misma tras aplicar la transformación. Esto se utiliza para traducir formas de local space a world space. Deberás añadir los tests de colisión que desees y completar la inicialización de la tabla en el método <em>configureCollisionDispatching</em>. Puedo adelantar que para la versión 0.2 de STC (Sion Tower Collisions) estoy implementando la forma <em>OrientedBox</em> y sus correspondientes tests de colisión.</p>
<p>Hasta aquí la tercera entrega de los artículos sobre el sistema de detección de colisiones de Sion Tower.</p>

      
    </div>
    
        <div class=pagination>
        <ul class="pagination">
            <li>
                <a href="../../">««</a>
            </li>
            
            <li>
                <a href="../../page/45/">«</a>
            </li>
            
            <li class="active">
                <a href="../../page/46/">46</a>
            </li>
            
            <li>
                <a href="../../page/47/">»</a>
            </li>
            
            <li>
                <a href="../../page/63/">»»</a>
            </li>
        </ul>
    </div>
  </div>
</div>


<script type="text/javascript">
var disqus_shortname = "siondream";
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>


<script src="../../js/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

<script
  src="https://code.jquery.com/jquery-3.6.0.min.js"
  integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4="
  crossorigin="anonymous"></script>
<script src="../../js/load-photoswipe.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.js" integrity="sha256-UplRCs9v4KXVJvVY+p+RSo5Q4ilAUXh7kpjyIP5odyc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe-ui-default.min.js" integrity="sha256-PWHOlUzc96pMc8ThwRIXPn8yH4NOLu42RQ0b9SpnpFk=" crossorigin="anonymous"></script>
</body>
</html>

