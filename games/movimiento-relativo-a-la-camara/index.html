<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/>

  <title>Movimiento relativo a la cámara &middot; David Saltares</title>

  
  <link rel="stylesheet" href="../../css/poole.css">
  <link rel="stylesheet" href="../../css/hyde.css">
  <link rel="stylesheet" href="../../css/poole-overrides.css">
  <link rel="stylesheet" href="../../css/hyde-overrides.css">
  <link rel="stylesheet" href="../../css/hyde-x.css">
  <link rel="stylesheet" href="../../css/highlight/zenburn.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../touch-icon-144-precomposed.png">
  <link href="../../img/favicon.png" rel="icon">

  
  
  
  

  <meta name="description" content="">
  <meta name="keywords" content="">
  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-4440744-3', 'auto');
    ga('send', 'pageview');
  </script>
  

  
  <link rel="canonical" href="https://saltares.com/games/movimiento-relativo-a-la-camara/" itemprop="url" />
</head>
<body>
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="../../"><img src="../../img/profile.jpg"
             alt="profile-picture" id="profile-img" title="David Saltares"></a>
      <h1><a href="../../">David Saltares</a></h1>
      <p class="lead">Software Development</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="../../">Blog</a></li>
      
      <li class="sidebar-nav-item"><a href="../../about">About</a></li>
      
      <li class="sidebar-nav-item"><a href="../../apps-tools">Apps &amp; Tools</a></li>
      
      <li class="sidebar-nav-item"><a href="../../game-jams">Game Jams</a></li>
      
      <li class="sidebar-nav-item"><a href="../../games">Games</a></li>
      
      <li class="sidebar-nav-item"><a href="../../libgdx-cross-platform-game-development-cookbook">Libgdx Cookbook</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a href="http://github.com/dsaltares"><i class="fa fa-github-square fa-2x"></i></a>
      
      
      <a href="https://www.linkedin.com/in/davidsaltares"><i class="fa fa-linkedin-square fa-2x"></i></a>
      
      
      <a href="http://twitter.com/d_saltares"><i class="fa fa-twitter-square fa-2x"></i></a>
      <a href="https://www.youtube.com/channel/UCw375yUExJOVIEHmvmPFWyg"><i class="fa fa-youtube-square fa-2x"></i></a>
      <a href="../../index.xml" type="application/rss+xml"><i class="fa fa-rss-square fa-2x"></i></a>
      </li>
    </ul>

    

    <div class="copyright">
      <p>
        &copy; 2021 David Saltares.<br/>
        Powered by <a href="http://gohugo.io">Hugo</a> and <a href="https://github.com/zyro/hyde-x">Hyde-X.</a><br/>
        Hosted on <a href="https://pages.github.com/">Github Pages</a>.
      </p>
    </div>
  </div>
</div>


<div class="content container">
  <div class="post">
    <h1 class="post-title">Movimiento relativo a la cámara</h1>
    <span class="post-date">Dec 26, 2010 &middot; 5 minute read &middot; <a href="https://saltares.com/games/movimiento-relativo-a-la-camara/#disqus_thread">Comments</a>
    
    <br/>
    <a class="label" href="../../categories/games-development">Games development</a>
    </span>
    <p><img src="../../img/wp/movimiento-camara.png" alt="movimiento-camara.png"></p>
<p>En la mayoría de videojuegos en tercera persona, <strong>la dirección hacia la que se mueve el personaje depende de la orientación de la cámara</strong>. A pesar de que Sion Tower es un tower defense, controlamos a un personaje en tercera persona y, por tanto, debía incorporar este sistema. Estos días he estado exprimiendo los sesos para implementar dicho movimiento. ¡Por fin! Tras decenas de diagramas con vectores, ángulos y sistemas de coordenadas, lo he conseguido. En este artículo <strong>explico un sencillo algoritmo para conseguirlo</strong>.</p>
<h3 id="qué-queremos-conseguir">¿Qué queremos conseguir?</h3>
<p>El siguiente diagrama muestra el <strong>sistema de coordenadas de Ogre</strong>. Imaginad que nuestro personaje se encuentra en el origen <em>p = (0, 0, 0)</em> y que la cámara está en el <em>c = (0, 0, 50)</em> mirando hacia el origen. Nuestras teclas de movimiento son las clásicas: WASD. Al pulsar W el personaje debe moverse en la dirección negativa del eje Z, en cambio, si pulsamos D deberá hacerlo en la dirección positiva del eje X.</p>
<p>En cambio, si la cámara se situase en <em>c = (50, 0, 0)</em> mirando a <em>(0, 0, 0)</em> las teclas no tendrían el mismo efecto en términos absolutos, aunque se mantiene idéntico si tomamos como punto de referencia a la cámara. Si pulsamos W el personaje se desplazará en la dirección negativa del eje X. En el caso de que pulsemos D, el personaje se dirigirá en la dirección negativa del eje Z.</p>
<p><img src="../../img/wp/coordenadas.png" alt="coordenadas.png"></p>
<p>Por supuesto, <strong>el personaje deberá girarse</strong> para mirar hacia la dirección del desplazamiento. A continuación, detallamos la manera de implementar este sistema de movimiento.</p>
<h3 id="algoritmo-objetos-implicados">Algoritmo: objetos implicados</h3>
<p>Este pequeño algoritmo está orientado al motor de renderizado Ogre3D y la biblioteca de dispositivos de entrada OIS aunque su filosofía es válida para otras herramientas. Lo ideal sería utilizar clases para el personaje y otros elementos aunque, en esta ocasión, he preferido no hacerlo en favor de la simplicidad del ejemplo.</p>
<p>Partimos de los siguientes objetos:</p>
<pre><code>Ogre::SceneNode* nodoPersonaje; // Nodo que representa al personaje
Ogre::Vector3 direccionObjetivo; // Relativa a la cámara
Ogre::Vector3 direccionActual; // Relativa a la cámara
Ogre::Vector3 velocidad; // Velocidad del personaje
bool andando; // true si el personaje se está desplazando
OIS::Keyboard* teclado; // Teclado para controlar al personaje
</code></pre><h3 id="algoritmo-desplazamiento-del-personaje">Algoritmo: desplazamiento del personaje</h3>
<p>En cada frame debemos <strong>tomar la dirección de la cámara</strong> y quedarnos con su componente x y z ya que nos movemos en el plano. Esa será nuestra dirección <em>&ldquo;hacia delante&rdquo;</em>. Es muy sencillo obtener la dirección &ldquo;<em>hacia la derecha&rdquo;</em>, simplemente intercambiamos las componentes x y z cambiándole el signo a la z de <em>&ldquo;hacia delante&rdquo;</em>.</p>
<p><strong>La dirección objetivo</strong> de este frame se puede calcular consultando las <strong>pulsaciones de las teclas</strong> y <strong>combinando los dos vectores</strong> anteriores utilizando sumas o restas. Nos podremos mover en 8 direcciones distintas. Por ejemplo, si deseamos dirigirnos hacia atrás a la izquierda tendremos: <em>direccionObjetivo = -delante – derecha</em>. Finalmente, <strong>la dirección objetivo debe ser normalizada</strong>, es decir, que el módulo del vector sea igual a 1. Esto es muy importante si no queremos que la velocidad del personaje se vea alterada. Finalmente, aplicamos el desplazamiento teniendo en cuenta la velocidad, la dirección y el tiempo en milisegundos desde el último frame. Esta técnica se conoce como <strong>LERP</strong> (Linear Interpolation).</p>
<h3 id="algoritmo-orientación-del-personaje">Algoritmo: orientación del personaje</h3>
<p>Sólo nos queda corregir la orientación del personaje para que mire hacia la dirección en la que se desplaza. Ogre pone a nuestra disposición el método <em>Vector3::getRotationTo</em> que, dado un vector nos devuelve el cuaternio a aplicar de forma que tras la rotación quede alineado con el segundo. <strong>Los cuaternios se utilizan para representar rotaciones</strong> en el espacio y están compuestos por un ángulo y un eje (en este caso el y). Si multiplicamos la rotación necesaria por la que ya posee el nodo del personaje, éste mirará hacia donde deseamos. Es importante el orden de los operadores ya que el producto de cuaternios no es conmutativo.</p>
<h3 id="algoritmo-código-completo">Algoritmo: código completo</h3>
<p>He aquí el código completo:</p>
<pre><code>using namespace Ogre;

void EstadoJuego::actualizarPersonaje(Ogre::Real deltaT) {
    // Tomamos la dirección de la cámara
    Vector3 delante = camara-&gt;getDirection(); 
    delante.y = 0;

    // Vector relativo a la cámara, ortogonal hacia su derecha
    Vector3 derecha(-delante.z, 0, delante.x);

    // Calculamos la dirección objetivo en función de la pulsación de las
    // teclas.
    if (teclado-&gt;isKeyDown(OIS::KC_W) &amp;&amp; teclado-&gt;isKeyDown(OIS::KC_D)) {
        direccionObjetivo = delante + derecha;
        andando = true;
    }
    else if (teclado-&gt;isKeyDown(OIS::KC_W) &amp;&amp; teclado-&gt;isKeyDown(OIS::KC_A)) {
        direccionObjetivo = delante - derecha;
        andando = true;
    }
    else if (teclado-&gt;isKeyDown(OIS::KC_S) &amp;&amp; teclado-&gt;isKeyDown(OIS::KC_D)) {
        direccionObjetivo = -delante + derecha;
        andando = true;
    }
    else if (teclado-&gt;isKeyDown(OIS::KC_S) &amp;&amp; teclado-&gt;isKeyDown(OIS::KC_A)) {
        direccionObjetivo = -delante - derecha;
        andando = true;
    }
    else if (teclado-&gt;isKeyDown(OIS::KC_W)) {
        direccionObjetivo = delante;
        andando = true;
    }
    else if (teclado-&gt;isKeyDown(OIS::KC_S)) {
        direccionObjetivo = -delante;
        andando = true;
    }
    else if (teclado-&gt;isKeyDown(OIS::KC_D)) {
        direccionObjetivo = derecha;
        andando = true;
    } 
    else if (teclado-&gt;isKeyDown(OIS::KC_A)){
        direccionObjetivo = -derecha;
        andando = true;
    }
    else
        andando = false;

    // Normalizamos el vector direccion
    direccionObjetivo.normalise();

    // Si debemos desplazarnos, aplicamos la traslación y calculamos la
    // rotación a aplicar
    if (andando) {
        nodoPersonaje-&gt;translate(velocidad * direccionObjetivo * deltaT,
                                 Node::TS_WORLD);
        if (direccionObjetivo != direccionActual) {
            Quaternion rotacion = direccionActual.getRotationTo(direccionObjetivo,
                                                                Vector3(0, 1, 0));
            Quaternion rotacionActual = nodoPersonaje-&gt;getOrientation()
            nodoPersonaje-&gt;setOrientation(orientacion * rotacionActual);
            direccionActual = direccionObjetivo;
        }
    }
}
</code></pre><h3 id="posibles-mejoras">Posibles mejoras</h3>
<p>Este algoritmo no está pensado para incluirse en un juego completo puesto que debe ser refinado. Sólo tenemos en cuenta la animación externa del personaje (desplazamiento y orientación). El algoritmo se olvida completamente de la animación interna. Si quieres un mejor resultado deberías incluirla (andar, detenerse, etc).</p>
<p>La rotación es brusca, lo ideal sería aplicarla poco a poco de forma que el personaje se girase suavemente. Para hacerlo deberíamos dividir la rotación en partes y aplicar una en cada frame.</p>
<h3 id="referencias">Referencias</h3>
<p>Seguramente quieras consultar fuentes mucho más fiables que yo:</p>
<ul>
<li><em>Game Engine Architecture (Jason Gregory)</em>: libro que cubre todos los aspectos a la hora de desarrollar un motor de juego. Contiene una sección de matemáticas muy bien explicada.</li>
<li><a href="http://en.wikipedia.org/wiki/Lerp_%28computing%29"><em>LERP (Wikipedia)</em></a></li>
<li><a href="http://www.cprogramming.com/tutorial/3d/quaternions.html"><em>Quaternios (Confuted)</em></a>: si esto de los cuaternios te ha sonado a chino te recomiendo que consultes este artículo en el que se hace una pequeña introducción.</li>
<li><a href="http://www.ogre3d.org/docs/api/html/index.html"><em>Documentación oficial de Ogre</em></a>: para obtener más detalles sobre las clases y los métodos empleados.</li>
</ul>

  </div>
  <div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'siondream';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>


<script src="../../js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="../../js/load-photoswipe.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.js" integrity="sha256-UplRCs9v4KXVJvVY+p+RSo5Q4ilAUXh7kpjyIP5odyc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe-ui-default.min.js" integrity="sha256-PWHOlUzc96pMc8ThwRIXPn8yH4NOLu42RQ0b9SpnpFk=" crossorigin="anonymous"></script>
</body>
</html>

