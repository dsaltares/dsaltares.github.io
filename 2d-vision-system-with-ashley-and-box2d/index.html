<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/touch-icon-144-precomposed.png"/><title>2D vision system with Ashley and Box2D · David Saltares</title><meta name="robots" content="index,follow"/><meta name="description" content="Engineering Leadership &amp; Software Development"/><meta property="og:title" content="2D vision system with Ashley and Box2D · David Saltares"/><meta property="og:description" content="Engineering Leadership &amp; Software Development"/><meta property="og:url" content="https://saltares.com/2d-vision-system-with-ashley-and-box2d"/><meta property="og:type" content="website"/><link rel="canonical" href="https://saltares.com/2d-vision-system-with-ashley-and-box2d"/><meta name="keywords" content=""/><meta name="next-head-count" content="12"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/_next/static/css/592216306eff0874.css" as="style"/><link rel="stylesheet" href="/_next/static/css/592216306eff0874.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-59abf025137dee37.js" defer=""></script><script src="/_next/static/chunks/framework-9b5d6ec4444c80fa.js" defer=""></script><script src="/_next/static/chunks/main-e42aac98337d61c6.js" defer=""></script><script src="/_next/static/chunks/pages/_app-89283805d41ea493.js" defer=""></script><script src="/_next/static/chunks/c16184b3-9b756f0214555638.js" defer=""></script><script src="/_next/static/chunks/2cca2479-c0f2c9f2f2dc1702.js" defer=""></script><script src="/_next/static/chunks/252-64d0c1a5eecbfabd.js" defer=""></script><script src="/_next/static/chunks/167-7d296999b3b0013a.js" defer=""></script><script src="/_next/static/chunks/962-68c39fb6207889be.js" defer=""></script><script src="/_next/static/chunks/673-8982310ab2fdaad5.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bslug%5D-73432d84cbff39d9.js" defer=""></script><script src="/_next/static/fjvCXZV6odoyGVI_9M9nM/_buildManifest.js" defer=""></script><script src="/_next/static/fjvCXZV6odoyGVI_9M9nM/_ssgManifest.js" defer=""></script><style data-href="https://fonts.googleapis.com/css2?family=PT+Sans:wght@400;700&display=swap">@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79P0Y.woff) format('woff')}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh4Oo.woff) format('woff')}@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79D0-ExcOPIDUg-g.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79D0aExcOPIDUg-g.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79D0yExcOPIDUg-g.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79D0KExcOPIDU.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh0OOtLR8a8zILig.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh0OqtLR8a8zILig.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh0OCtLR8a8zILig.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh0O6tLR8a8zI.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><div class="flex flex-col md:flex-row font-sans text-xl w-full"><aside class="md:max-w-[360px] bg-primary px-10 py-10 text-white text-xl md:fixed md:top-0 md:left-0 md:h-full flex flex-col justify-end items-center md:items-start"><div><a href="/"><div class="mb-5"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27200%27%20height=%27200%27/%3e"/></span><img alt="profile picture" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="rounded-full" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="profile picture" src="/img/profile.webp" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" class="rounded-full" loading="lazy"/></noscript></span></div><h1 class="text-white font-bold text-4xl leading-10">David Saltares</h1></a></div><p class="text-contentLight text-2xl mb-5 leading-9 text-center md:text-left">Engineering Leadership &amp; Software Development</p><a href="https://tinyletter.com/dsaltares/"><p class="mb-5">✉️ Subscribe</p></a><nav><ul class="mb-5 flex flex-col items-center md:items-start list-none pl-0"><li class="leading-7"><a href="/">Blog</a></li><li class="leading-7"><a href="/about-me/">About</a></li><li class="leading-7"><a href="/apps-tools/">Apps &amp; Tools</a></li><li class="leading-7"><a href="/game-jams/">Game Jams</a></li><li class="leading-7"><a href="/games/">Games</a></li><li class="leading-7"><a href="/libgdx-cross-platform-game-development-cookbook/">Libgdx Cookbook</a></li></ul></nav><ul class="mb-5 list-none pl-0"><li class="inline"><a aria-label="Github profile" href="https://github.com/dsaltares"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="square-github" class="svg-inline--fa fa-square-github text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM277.3 415.7c-8.4 1.5-11.5-3.7-11.5-8 0-5.4.2-33 .2-55.3 0-15.6-5.2-25.5-11.3-30.7 37-4.1 76-9.2 76-73.1 0-18.2-6.5-27.3-17.1-39 1.7-4.3 7.4-22-1.7-45-13.9-4.3-45.7 17.9-45.7 17.9-13.2-3.7-27.5-5.6-41.6-5.6-14.1 0-28.4 1.9-41.6 5.6 0 0-31.8-22.2-45.7-17.9-9.1 22.9-3.5 40.6-1.7 45-10.6 11.7-15.6 20.8-15.6 39 0 63.6 37.3 69 74.3 73.1-4.8 4.3-9.1 11.7-10.6 22.3-9.5 4.3-33.8 11.7-48.3-13.9-9.1-15.8-25.5-17.1-25.5-17.1-16.2-.2-1.1 10.2-1.1 10.2 10.8 5 18.4 24.2 18.4 24.2 9.7 29.7 56.1 19.7 56.1 19.7 0 13.9.2 36.5.2 40.6 0 4.3-3 9.5-11.5 8-66-22.1-112.2-84.9-112.2-158.3 0-91.8 70.2-161.5 162-161.5S388 165.6 388 257.4c.1 73.4-44.7 136.3-110.7 158.3zm-98.1-61.1c-1.9.4-3.7-.4-3.9-1.7-.2-1.5 1.1-2.8 3-3.2 1.9-.2 3.7.6 3.9 1.9.3 1.3-1 2.6-3 3zm-9.5-.9c0 1.3-1.5 2.4-3.5 2.4-2.2.2-3.7-.9-3.7-2.4 0-1.3 1.5-2.4 3.5-2.4 1.9-.2 3.7.9 3.7 2.4zm-13.7-1.1c-.4 1.3-2.4 1.9-4.1 1.3-1.9-.4-3.2-1.9-2.8-3.2.4-1.3 2.4-1.9 4.1-1.5 2 .6 3.3 2.1 2.8 3.4zm-12.3-5.4c-.9 1.1-2.8.9-4.3-.6-1.5-1.3-1.9-3.2-.9-4.1.9-1.1 2.8-.9 4.3.6 1.3 1.3 1.8 3.3.9 4.1zm-9.1-9.1c-.9.6-2.6 0-3.7-1.5s-1.1-3.2 0-3.9c1.1-.9 2.8-.2 3.7 1.3 1.1 1.5 1.1 3.3 0 4.1zm-6.5-9.7c-.9.9-2.4.4-3.5-.6-1.1-1.3-1.3-2.8-.4-3.5.9-.9 2.4-.4 3.5.6 1.1 1.3 1.3 2.8.4 3.5zm-6.7-7.4c-.4.9-1.7 1.1-2.8.4-1.3-.6-1.9-1.7-1.5-2.6.4-.6 1.5-.9 2.8-.4 1.3.7 1.9 1.8 1.5 2.6z"></path></svg></a></li><li class="inline"><a aria-label="Linkedin profile" href="https://www.linkedin.com/in/davidsaltares/"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="linkedin" class="svg-inline--fa fa-linkedin text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg></a></li><li class="inline"><a aria-label="Twitter profile" href="https://twitter.com/dsaltares"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="square-twitter" class="svg-inline--fa fa-square-twitter text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-48.9 158.8c.2 2.8.2 5.7.2 8.5 0 86.7-66 186.6-186.6 186.6-37.2 0-71.7-10.8-100.7-29.4 5.3.6 10.4.8 15.8.8 30.7 0 58.9-10.4 81.4-28-28.8-.6-53-19.5-61.3-45.5 10.1 1.5 19.2 1.5 29.6-1.2-30-6.1-52.5-32.5-52.5-64.4v-.8c8.7 4.9 18.9 7.9 29.6 8.3a65.447 65.447 0 0 1-29.2-54.6c0-12.2 3.2-23.4 8.9-33.1 32.3 39.8 80.8 65.8 135.2 68.6-9.3-44.5 24-80.6 64-80.6 18.9 0 35.9 7.9 47.9 20.7 14.8-2.8 29-8.3 41.6-15.8-4.9 15.2-15.2 28-28.8 36.1 13.2-1.4 26-5.1 37.8-10.2-8.9 13.1-20.1 24.7-32.9 34z"></path></svg></a></li><li class="inline"><a aria-label="RSS feed" href="https://saltares.com/index.xml"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="square-rss" class="svg-inline--fa fa-square-rss text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M64 32C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V96c0-35.3-28.7-64-64-64H64zM96 136c0-13.3 10.7-24 24-24c137 0 248 111 248 248c0 13.3-10.7 24-24 24s-24-10.7-24-24c0-110.5-89.5-200-200-200c-13.3 0-24-10.7-24-24zm0 96c0-13.3 10.7-24 24-24c83.9 0 152 68.1 152 152c0 13.3-10.7 24-24 24s-24-10.7-24-24c0-57.4-46.6-104-104-104c-13.3 0-24-10.7-24-24zm64 120c0 17.7-14.3 32-32 32s-32-14.3-32-32s14.3-32 32-32s32 14.3 32 32z"></path></svg></a></li><li class="inline"><a rel="me" href="https://fosstodon.org/@dsaltares"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="mastodon" class="svg-inline--fa fa-mastodon text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48 0 0 0-63.72 28.5-63.72 125.7 0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54 0 0 1-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"></path></svg></a></li></ul><p class="text-contentLight text-lg">© 2023 David Saltares.</p></aside><div class="md:max-w-[360px] w-full hidden md:block flex-grow-0 flex-shrink-0"></div><div class="flex flex-col main-content"><main class="w-full max-w-[720px] pr-4 py-10 pl-5 md:py-20 md:pl-20"><article class="text-content mb-10"><div><a href="/2d-vision-system-with-ashley-and-box2d/"><h1 class="font-bold text-4xl mb-2 text-primary">2D vision system with Ashley and Box2D</h1></a><p class="flex text-contentLight mb-1">Jan 30 2016 · 9 min read<span> · </span><a class="text-contentLink" href="/2d-vision-system-with-ashley-and-box2d/#disqus_thread">Comments</a></p><div class="mb-3"><div class="flex flex-row gap-1"><a class="px-2 py-1 bg-slate-900 text-white rounded font-bold text-sm" href="/categories/games-development/">Games development</a></div></div></div><img class="mb-1" src="/img/wp/javaw-2016-01-22-22-59-09-54-1-e1454169566721.webp" alt="javaw-2016-01-22-22-59-09-54-1-e1454169566721.png"/>
<p>In <a class="text-contentLink text-xl" href="/game-jams/sloppynauts/">Sloppynauts</a> the player had to remain undetected, avoiding CCTV cameras and alien baddies. We constantly had to determine who could see who and whether the player was hidden behind something. We wrote a nice reusable system using <a class="text-contentLink text-xl" href="https://github.com/libgdx/ashley">Ashley</a> and <a class="text-contentLink text-xl" href="http://box2d.org/">Box2D</a> and I think it&quot;d be a shame if it went to waste. So here it is in case you&quot;d like to use it.</p>
<p>This 2D vision system is generic enough to work with both side-scrolling and top-down games. Surely it can be further optimised and tailored to your needs… Hey, it was done for a game jam! Nevertheless, it could be a decent starting point!</p>
<p>Before we get down to business, make sure you understand what Ashley is and what <a class="text-contentLink text-xl" href="http://www.gamedev.net/page/resources/_/technical/game-programming/understanding-component-entity-systems-r3013">component based entity systems</a> are all about.</p>
<h3>Vision System concepts</h3>
<p>We want to give some of the entities in our game world the ability to see other entities. Both observers and observables will necessarily have a location in our game world. However, we need some extra information about our observers, specifically the area they can cover at any given point in time, ie. their field of view. In the diagram below you can see a couple of observers and three observables. One of the observables can be seen, the second one is complete outside of both FOVs whilst the third one is hidden behind a box. <img class="mb-1" src="/img/wp/vision-system-diagram-1.webp" alt="vision-system-diagram-1.png"/> We simply want to ask our system: <em>&quot;can this entity see this other entity?&quot;</em></p>
<h3>Observable and Observer components</h3>
<p>Our <code class="text-code bg-codeBg px-2 py-1 text-base rounded">Observable</code> component is pretty trivial, it simply has a position.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">public class ObservableComponent implements Component {
    public Vector2 position = new Vector2();
}</code></pre></div>
<p>The <code class="text-code bg-codeBg px-2 py-1 text-base rounded">Observer</code> component has a little more information.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">public class ObserverComponent implements Component {
    public Vector2 position = new Vector2();
    public float angle = 0.0f;
    public float distance = 5.0f;
    public float fovAngle = 45.0f;
}</code></pre></div>
<ul>
<li><code class="text-code bg-codeBg px-2 py-1 text-base rounded">angle</code>: where the entity is looking at.</li>
<li><code class="text-code bg-codeBg px-2 py-1 text-base rounded">distance</code>: how far it can see.</li>
<li><code class="text-code bg-codeBg px-2 py-1 text-base rounded">fovAngle</code>: the angle it can cover. Members are initialised with default values, you can obviously change these.</li>
</ul>
<p>###The Vision Entity System</p>
<p>The <code class="text-code bg-codeBg px-2 py-1 text-base rounded">VisionSystem</code> is where the magic happens, you can see the full outline below.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">public class VisionSystem extends IteratingSystem implements EntityListener {
    public VisionSystem(World world) {}

    public boolean canSee(Entity observer, Entity observable) {}

    // EntitySystem
    public void addedToEngine(Engine engine) {}
    public void removedFromEngine(Engine engine) {}

    // EntityListener
    public void entityAdded(Entity entity) {}
    public void entityRemoved(Entity entity) {}

    // IteratingSystem
    protected void processEntity(Entity observer, float deltaTime) {}

    // Utility
    private void updateVision(Entity observer) {}
    private void updateVision(Entity observer, Entity observable) {}
    private boolean inFov(Entity entity, Entity target) {}
    private void raycast(Entity entity, Entity target) {}
    private void addToVision(Entity observer, Entity observable) {}
    private void removeFromVision(Entity observer, Entity observable) {}
}</code></pre></div>
<p>The constructor will take a Box2D <code class="text-code bg-codeBg px-2 py-1 text-base rounded">World</code> as we need it to make line of sight (LoS) queries. We will also tell Ashley that we want the system to process entities with <code class="text-code bg-codeBg px-2 py-1 text-base rounded">ObserverComponent</code>.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">public VisionSystem(World world) {
    super(Family.all(ObserverComponent.class).get());

    this.world = world;
}</code></pre></div>
<p>In order to be able to answer the <code class="text-code bg-codeBg px-2 py-1 text-base rounded">canSee()</code> question, we will keep a map of observer entities to the collection of observables that it can see at any given time. The map will be updated every frame.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">private ObjectMap&amp;lt;Entity, ObjectSet&amp;lt;Entity&amp;gt;&amp;gt; vision = new ObjectMap();</code></pre></div>
<p>We will also need the collection of entities with an <code class="text-code bg-codeBg px-2 py-1 text-base rounded">ObservableComponent</code>, they are the candidates to make into the vision map as targets.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">private ImmutableArray&amp;lt;Entity&amp;gt; observables;</code></pre></div>
<p>The <code class="text-code bg-codeBg px-2 py-1 text-base rounded">addedToEngine()</code> and <code class="text-code bg-codeBg px-2 py-1 text-base rounded">removedFromEngine()</code> methods are invoked whenever we register the system with the engine. We can hook into them to grab the immutable list of observables as well as to register our vision system as a listener for observers. That way, we can pre-populate and clear up our vision map as observers come and go.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">@Override
public void addedToEngine(Engine engine) {
    super.addedToEngine(engine);
    observables = engine.getEntitiesFor(
        Family.all(ObservableComponent.class).get()
    );
    engine.addEntityListener(getFamily(), this);
}

@Override
public void removedFromEngine(Engine engine) {
    super.removedFromEngine(engine);
    engine.removeEntityListener(this);
}

@Override
public void entityAdded(Entity entity) {
    vision.put(entity, new ObjectSet&amp;lt;Entity&amp;gt;());
}

@Override
public void entityRemoved(Entity entity) {
    vision.remove(entity);
}</code></pre></div>
<p>The <code class="text-code bg-codeBg px-2 py-1 text-base rounded">canSee()</code> method is quite trivial, we simply check if the observable is in the set of visible entities for the given observer.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">public boolean canSee(Entity observer, Entity observable) {
    ObjectSet&amp;lt;Entity&amp;gt; observables = vision.get(observer);

    if (observables == null) {
        return false;
    }

    return observables.contains(observable);
}</code></pre></div>
<p><code class="text-code bg-codeBg px-2 py-1 text-base rounded">VisionSystem</code> is an <code class="text-code bg-codeBg px-2 py-1 text-base rounded">IteratingSystem</code>, so we need to implement the <code class="text-code bg-codeBg px-2 py-1 text-base rounded">processEntity()</code> method, which will be invoked once a frame for every observer registered with the engine. Here is where the vision map entry for the observer gets updated.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">@Override
protected void processEntity(Entity observer, float deltaTime) {
    updateVision(observer);
}</code></pre></div>
<p>In order to do that, we go through the collection of observables and check whether they should be added or removed from the observer&#x27;s visible entities.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">private void updateVision(Entity observer) {
    for (Entity observable : observables) {
        updateVision(observer, observable);
    }
}</code></pre></div>
<p>The <code class="text-code bg-codeBg px-2 py-1 text-base rounded">addToVision()</code> and <code class="text-code bg-codeBg px-2 py-1 text-base rounded">removeFromVision()</code> utility methods will simply help us update the vision map. We make the assumption that there will always be an entry for every observer in the engine.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">private void addToVision(Entity observer, Entity observable) {
    vision.get(observer).add(observable)
}

private void removeFromVision(Entity observer, Entity observable) {
    vision.get(observer).remove(observable)
}</code></pre></div>
<p>To know whether an observer can see an observable two conditions need to be met: the observable has to be within the observer&#x27;s FoV and there must be an unobstructed LoS between the two. Querying the Box2D world can be costly, that is why we short-circuit the FoV check with the raycast.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">private void updateVision(Entity observer, Entity observable) {
    if (!inFov(observer, observable)) {
        removeFromVision(observer, observable);
        return;
    }

    raycast(observer, observable);
}</code></pre></div>
<p>To achieve <a class="text-contentLink text-xl" href="https://github.com/libgdx/ashley/wiki/How-to-use-Ashley#retrieving-components-with-componentmapper">super-fast component retrieval</a>, we use <code class="text-code bg-codeBg px-2 py-1 text-base rounded">ComponentMapper</code>.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">private ComponentMapper&amp;lt;ObservableComponent&amp;gt; observableMapper = ComponentMapper.getFor(ObservableComponent.class);
private ComponentMapper&amp;lt;ObserverComponent&amp;gt; observerMapper = ComponentMapper.getFor(ObserverComponent.class);</code></pre></div>
<p>First, check whether the observable is within the vision distance of the observer and if it is, we check whether or not the angle between the two falls within the observer&#x27;s vision angle. The math is be pretty simple here.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">private boolean inFov(Entity entity, Entity target) {
    ObserverComponent observer = observerMapper.get(entity);
    ObservableComponent observable = observableMapper.get(target);

    if (observer.position.isZero() ||
        observable.position.isZero() ||
        observer.position.dst2(observable.position) &amp;gt;
        observer.distance * observer.distance) {
        return false;
    }

    toObservable.set(observable.position);
    toObservable.sub(observer.position);

    float toObservableAngle = toObservable.angle();
    float angleDifference = Math.abs(toObservableAngle - observer.angle);

    angleDifference = Math.min(angleDifference, 360.0f - angleDifference);

    if (angleDifference &amp;gt; observer.fovAngle) {
        return false;
    }

    return true;
}</code></pre></div>
<p>It&#x27;s time to perform our raycast, which will go from the observer to the observable. Box2D raycasts take a reference to the <code class="text-code bg-codeBg px-2 py-1 text-base rounded">Callback</code> interface to handle geometry hits. The handler is notified on every fixture hit. Box2D will pass the fixture it encountered as well as the fraction along the segment at which the hit happened. <img class="mb-1" src="/img/wp/vision-system-raycast.webp" alt="vision-system-raycast.png"/> The <code class="text-code bg-codeBg px-2 py-1 text-base rounded">VisionSystem</code> has an inner <code class="text-code bg-codeBg px-2 py-1 text-base rounded">VisionCallback</code> implementation, which gets reused for every raycast, that way we don&#x27;t need to constantly allocate memory.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">private VisionCallback callback = new VisionCallback();</code></pre></div>
<p>Its outline is pretty simple.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">private class VisionCallback implements RayCastCallback {
    private Entity observer;
    private Entity observable;
    private float minFraction;
    private float observableFraction;

    public void prepare(Entity observer, Entity observable) {}
    public boolean canSee() {}

    @Override
    public float reportRayFixture(Fixture fixture, Vector2 point, Vector2 normal, float fraction) {}
}</code></pre></div>
<p>Before the raycast, we need to prepare the callback.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">public void prepare(Entity observer, Entity observable) {
    this.observer = observer;
    this.observable = observable;
    this.minFraction = Float.MAX_VALUE;
    this.observableFraction = Float.MAX_VALUE;
}</code></pre></div>
<p>Whenever the ray hits a fixture, the <code class="text-code bg-codeBg px-2 py-1 text-base rounded">reportRayFixture()</code> method gets called. Box2D bodies can hold arbitrary data, i.e. a reference to any <code class="text-code bg-codeBg px-2 py-1 text-base rounded">Object</code>. We conveniently set this to be a referene to the <code class="text-code bg-codeBg px-2 py-1 text-base rounded">Entity</code> the body belongs to. That way we can check if the fixture we hit is part of the observer itself. Whenever we encounter the observable we record how far along the ray segment it is.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">@Override
public float reportRayFixture(Fixture fixture, Vector2 point, Vector2 normal, float fraction) {
    Object data = fixture.getBody().getUserData();

    if (data == observer) {
        return -1;
    }

    minFraction = fraction;

    if (data == observable) {
        observableFraction = fraction;
        return fraction;
    }
    return 0;
}</code></pre></div>
<p>Thanks to the information recorded during the raycast, we can then ask <code class="text-code bg-codeBg px-2 py-1 text-base rounded">VisionCallback</code> whether the object is visible. This question is easy to answer, it will be visible if and only if the observable was the closest object the ray bumped into.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">public boolean canSee() {
    return observableFraction &amp;lt; 1.0f &amp;amp;&amp;amp; observableFraction &amp;lt;= minFraction;
}</code></pre></div>
<p>The system <code class="text-code bg-codeBg px-2 py-1 text-base rounded">raycast()</code> method becomes very simple and can easily update the vision map.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">private void raycast(Entity entity, Entity target) {
    ObserverComponent observer = observerMapper.get(entity);
    ObservableComponent observable = observableMapper.get(target);

    callback.prepare(entity, target);

    world.rayCast(
        callback,
        observer.position,
        observable.position
    );

    if (callback.canSee()) {
        addToVision(entity, target);
    }
    else {
        removeFromVision(entity, target);
    }
}</code></pre></div>
<p>That&#x27;s it, we have a nice, reusable vision system for any 2D game!</p>
<h3>Room for improvement</h3>
<p>Like I said, this is game jam code, you have been warned! Here&#x27;s a few things I could think of to make the system more efficient and nicer in general.</p>
<ul>
<li>Collision filtering: Box2D allows us to set bit masks to bodies to filter collisions. We can leverage that to select behind which bodies observables can hide.</li>
<li>Space partitioning: we can use a <a class="text-contentLink text-xl" href="https://en.wikipedia.org/wiki/Quadtree">quadtree</a> to avoid processing every observable for each observer.</li>
<li>Deferred raycasting: we probably don&#x27;t need one frame accuracy, so we can update the vision maps for a subset of observers each frame. The player won&#x27;t ever notice if that guard spotted him a couple of frames later.</li>
<li>Prioritisation: if you ever find yourself in a situation where there are just too many observables and observers you can add some sort of prioritisation to your deferred raycast queue, so the important ones get processed first. You may also have to keep track of the time spent in the queue to avoid starvation.</li>
</ul>
<p>Some games may need slightly more complex vision models. For instance, you may add a small detection circle around observers to represent some kind of sixth sense. A guard would notice a presence right behind him after a short while. That would be quite easy to add to our <code class="text-code bg-codeBg px-2 py-1 text-base rounded">VisionSystem</code>.</p>
<img class="mb-1" src="/img/wp/vision-system-alternate-model.webp" alt="vision-system-alternate-model.png"/>
<h3>Use it, improve it, give feedback</h3>
<p>Find the full source for the vision system here:</p>
<ul>
<li><a class="text-contentLink text-xl" href="https://github.com/dsaltares/libgdxjam/blob/master/core/src/com/siondream/libgdxjam/ecs/systems/VisionSystem.java"><code class="text-code bg-codeBg px-2 py-1 text-base rounded">VisionSystem</code></a></li>
<li><a class="text-contentLink text-xl" href="https://github.com/dsaltares/libgdxjam/blob/master/core/src/com/siondream/libgdxjam/ecs/components/ObserverComponent.java"><code class="text-code bg-codeBg px-2 py-1 text-base rounded">ObserverComponent</code></a></li>
<li><a class="text-contentLink text-xl" href="https://github.com/dsaltares/libgdxjam/blob/master/core/src/com/siondream/libgdxjam/ecs/components/ObservableComponent.java"><code class="text-code bg-codeBg px-2 py-1 text-base rounded">ObservableComponent</code></a></li>
</ul>
<p>Let me know what you think, especially if you use it. Would love some feedback on it!</p></article></main></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metadata":{"path":"content/post/2016-01-30-2d-vision-system-with-ashley-and-box2d.mdx","title":"2D vision system with Ashley and Box2D","date":"2016-01-30T16:07:46.000Z","categories":["Games development"],"series":null,"description":null,"slug":"2d-vision-system-with-ashley-and-box2d","readingTime":"9 min read","draft":false,"disableComments":false,"keywords":[],"banner":null},"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    img: \"img\",\n    p: \"p\",\n    a: \"a\",\n    h3: \"h3\",\n    em: \"em\",\n    code: \"code\",\n    div: \"div\",\n    pre: \"pre\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.img, {\n      src: \"/img/wp/javaw-2016-01-22-22-59-09-54-1-e1454169566721.webp\",\n      alt: \"javaw-2016-01-22-22-59-09-54-1-e1454169566721.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In \", _jsx(_components.a, {\n        href: \"/game-jams/sloppynauts/\",\n        children: \"Sloppynauts\"\n      }), \" the player had to remain undetected, avoiding CCTV cameras and alien baddies. We constantly had to determine who could see who and whether the player was hidden behind something. We wrote a nice reusable system using \", _jsx(_components.a, {\n        href: \"https://github.com/libgdx/ashley\",\n        children: \"Ashley\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"http://box2d.org/\",\n        children: \"Box2D\"\n      }), \" and I think it\\\"d be a shame if it went to waste. So here it is in case you\\\"d like to use it.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This 2D vision system is generic enough to work with both side-scrolling and top-down games. Surely it can be further optimised and tailored to your needs… Hey, it was done for a game jam! Nevertheless, it could be a decent starting point!\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Before we get down to business, make sure you understand what Ashley is and what \", _jsx(_components.a, {\n        href: \"http://www.gamedev.net/page/resources/_/technical/game-programming/understanding-component-entity-systems-r3013\",\n        children: \"component based entity systems\"\n      }), \" are all about.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Vision System concepts\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We want to give some of the entities in our game world the ability to see other entities. Both observers and observables will necessarily have a location in our game world. However, we need some extra information about our observers, specifically the area they can cover at any given point in time, ie. their field of view. In the diagram below you can see a couple of observers and three observables. One of the observables can be seen, the second one is complete outside of both FOVs whilst the third one is hidden behind a box. \", _jsx(_components.img, {\n        src: \"/img/wp/vision-system-diagram-1.webp\",\n        alt: \"vision-system-diagram-1.png\"\n      }), \" We simply want to ask our system: \", _jsx(_components.em, {\n        children: \"\\\"can this entity see this other entity?\\\"\"\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Observable and Observer components\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Our \", _jsx(_components.code, {\n        children: \"Observable\"\n      }), \" component is pretty trivial, it simply has a position.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"public class ObservableComponent implements Component {\\n    public Vector2 position = new Vector2();\\n}\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"Observer\"\n      }), \" component has a little more information.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"public class ObserverComponent implements Component {\\n    public Vector2 position = new Vector2();\\n    public float angle = 0.0f;\\n    public float distance = 5.0f;\\n    public float fovAngle = 45.0f;\\n}\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"angle\"\n        }), \": where the entity is looking at.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"distance\"\n        }), \": how far it can see.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"fovAngle\"\n        }), \": the angle it can cover. Members are initialised with default values, you can obviously change these.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"###The Vision Entity System\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"VisionSystem\"\n      }), \" is where the magic happens, you can see the full outline below.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"public class VisionSystem extends IteratingSystem implements EntityListener {\\n    public VisionSystem(World world) {}\\n\\n    public boolean canSee(Entity observer, Entity observable) {}\\n\\n    // EntitySystem\\n    public void addedToEngine(Engine engine) {}\\n    public void removedFromEngine(Engine engine) {}\\n\\n    // EntityListener\\n    public void entityAdded(Entity entity) {}\\n    public void entityRemoved(Entity entity) {}\\n\\n    // IteratingSystem\\n    protected void processEntity(Entity observer, float deltaTime) {}\\n\\n    // Utility\\n    private void updateVision(Entity observer) {}\\n    private void updateVision(Entity observer, Entity observable) {}\\n    private boolean inFov(Entity entity, Entity target) {}\\n    private void raycast(Entity entity, Entity target) {}\\n    private void addToVision(Entity observer, Entity observable) {}\\n    private void removeFromVision(Entity observer, Entity observable) {}\\n}\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The constructor will take a Box2D \", _jsx(_components.code, {\n        children: \"World\"\n      }), \" as we need it to make line of sight (LoS) queries. We will also tell Ashley that we want the system to process entities with \", _jsx(_components.code, {\n        children: \"ObserverComponent\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"public VisionSystem(World world) {\\n    super(Family.all(ObserverComponent.class).get());\\n\\n    this.world = world;\\n}\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In order to be able to answer the \", _jsx(_components.code, {\n        children: \"canSee()\"\n      }), \" question, we will keep a map of observer entities to the collection of observables that it can see at any given time. The map will be updated every frame.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"private ObjectMap\u0026lt;Entity, ObjectSet\u0026lt;Entity\u0026gt;\u0026gt; vision = new ObjectMap();\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We will also need the collection of entities with an \", _jsx(_components.code, {\n        children: \"ObservableComponent\"\n      }), \", they are the candidates to make into the vision map as targets.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"private ImmutableArray\u0026lt;Entity\u0026gt; observables;\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"addedToEngine()\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"removedFromEngine()\"\n      }), \" methods are invoked whenever we register the system with the engine. We can hook into them to grab the immutable list of observables as well as to register our vision system as a listener for observers. That way, we can pre-populate and clear up our vision map as observers come and go.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"@Override\\npublic void addedToEngine(Engine engine) {\\n    super.addedToEngine(engine);\\n    observables = engine.getEntitiesFor(\\n        Family.all(ObservableComponent.class).get()\\n    );\\n    engine.addEntityListener(getFamily(), this);\\n}\\n\\n@Override\\npublic void removedFromEngine(Engine engine) {\\n    super.removedFromEngine(engine);\\n    engine.removeEntityListener(this);\\n}\\n\\n@Override\\npublic void entityAdded(Entity entity) {\\n    vision.put(entity, new ObjectSet\u0026lt;Entity\u0026gt;());\\n}\\n\\n@Override\\npublic void entityRemoved(Entity entity) {\\n    vision.remove(entity);\\n}\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"canSee()\"\n      }), \" method is quite trivial, we simply check if the observable is in the set of visible entities for the given observer.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"public boolean canSee(Entity observer, Entity observable) {\\n    ObjectSet\u0026lt;Entity\u0026gt; observables = vision.get(observer);\\n\\n    if (observables == null) {\\n        return false;\\n    }\\n\\n    return observables.contains(observable);\\n}\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"VisionSystem\"\n      }), \" is an \", _jsx(_components.code, {\n        children: \"IteratingSystem\"\n      }), \", so we need to implement the \", _jsx(_components.code, {\n        children: \"processEntity()\"\n      }), \" method, which will be invoked once a frame for every observer registered with the engine. Here is where the vision map entry for the observer gets updated.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"@Override\\nprotected void processEntity(Entity observer, float deltaTime) {\\n    updateVision(observer);\\n}\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In order to do that, we go through the collection of observables and check whether they should be added or removed from the observer's visible entities.\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"private void updateVision(Entity observer) {\\n    for (Entity observable : observables) {\\n        updateVision(observer, observable);\\n    }\\n}\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"addToVision()\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"removeFromVision()\"\n      }), \" utility methods will simply help us update the vision map. We make the assumption that there will always be an entry for every observer in the engine.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"private void addToVision(Entity observer, Entity observable) {\\n    vision.get(observer).add(observable)\\n}\\n\\nprivate void removeFromVision(Entity observer, Entity observable) {\\n    vision.get(observer).remove(observable)\\n}\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To know whether an observer can see an observable two conditions need to be met: the observable has to be within the observer's FoV and there must be an unobstructed LoS between the two. Querying the Box2D world can be costly, that is why we short-circuit the FoV check with the raycast.\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"private void updateVision(Entity observer, Entity observable) {\\n    if (!inFov(observer, observable)) {\\n        removeFromVision(observer, observable);\\n        return;\\n    }\\n\\n    raycast(observer, observable);\\n}\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To achieve \", _jsx(_components.a, {\n        href: \"https://github.com/libgdx/ashley/wiki/How-to-use-Ashley#retrieving-components-with-componentmapper\",\n        children: \"super-fast component retrieval\"\n      }), \", we use \", _jsx(_components.code, {\n        children: \"ComponentMapper\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"private ComponentMapper\u0026lt;ObservableComponent\u0026gt; observableMapper = ComponentMapper.getFor(ObservableComponent.class);\\nprivate ComponentMapper\u0026lt;ObserverComponent\u0026gt; observerMapper = ComponentMapper.getFor(ObserverComponent.class);\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"First, check whether the observable is within the vision distance of the observer and if it is, we check whether or not the angle between the two falls within the observer's vision angle. The math is be pretty simple here.\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"private boolean inFov(Entity entity, Entity target) {\\n    ObserverComponent observer = observerMapper.get(entity);\\n    ObservableComponent observable = observableMapper.get(target);\\n\\n    if (observer.position.isZero() ||\\n        observable.position.isZero() ||\\n        observer.position.dst2(observable.position) \u0026gt;\\n        observer.distance * observer.distance) {\\n        return false;\\n    }\\n\\n    toObservable.set(observable.position);\\n    toObservable.sub(observer.position);\\n\\n    float toObservableAngle = toObservable.angle();\\n    float angleDifference = Math.abs(toObservableAngle - observer.angle);\\n\\n    angleDifference = Math.min(angleDifference, 360.0f - angleDifference);\\n\\n    if (angleDifference \u0026gt; observer.fovAngle) {\\n        return false;\\n    }\\n\\n    return true;\\n}\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It's time to perform our raycast, which will go from the observer to the observable. Box2D raycasts take a reference to the \", _jsx(_components.code, {\n        children: \"Callback\"\n      }), \" interface to handle geometry hits. The handler is notified on every fixture hit. Box2D will pass the fixture it encountered as well as the fraction along the segment at which the hit happened. \", _jsx(_components.img, {\n        src: \"/img/wp/vision-system-raycast.webp\",\n        alt: \"vision-system-raycast.png\"\n      }), \" The \", _jsx(_components.code, {\n        children: \"VisionSystem\"\n      }), \" has an inner \", _jsx(_components.code, {\n        children: \"VisionCallback\"\n      }), \" implementation, which gets reused for every raycast, that way we don't need to constantly allocate memory.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"private VisionCallback callback = new VisionCallback();\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Its outline is pretty simple.\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"private class VisionCallback implements RayCastCallback {\\n    private Entity observer;\\n    private Entity observable;\\n    private float minFraction;\\n    private float observableFraction;\\n\\n    public void prepare(Entity observer, Entity observable) {}\\n    public boolean canSee() {}\\n\\n    @Override\\n    public float reportRayFixture(Fixture fixture, Vector2 point, Vector2 normal, float fraction) {}\\n}\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Before the raycast, we need to prepare the callback.\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"public void prepare(Entity observer, Entity observable) {\\n    this.observer = observer;\\n    this.observable = observable;\\n    this.minFraction = Float.MAX_VALUE;\\n    this.observableFraction = Float.MAX_VALUE;\\n}\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Whenever the ray hits a fixture, the \", _jsx(_components.code, {\n        children: \"reportRayFixture()\"\n      }), \" method gets called. Box2D bodies can hold arbitrary data, i.e. a reference to any \", _jsx(_components.code, {\n        children: \"Object\"\n      }), \". We conveniently set this to be a referene to the \", _jsx(_components.code, {\n        children: \"Entity\"\n      }), \" the body belongs to. That way we can check if the fixture we hit is part of the observer itself. Whenever we encounter the observable we record how far along the ray segment it is.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"@Override\\npublic float reportRayFixture(Fixture fixture, Vector2 point, Vector2 normal, float fraction) {\\n    Object data = fixture.getBody().getUserData();\\n\\n    if (data == observer) {\\n        return -1;\\n    }\\n\\n    minFraction = fraction;\\n\\n    if (data == observable) {\\n        observableFraction = fraction;\\n        return fraction;\\n    }\\n    return 0;\\n}\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Thanks to the information recorded during the raycast, we can then ask \", _jsx(_components.code, {\n        children: \"VisionCallback\"\n      }), \" whether the object is visible. This question is easy to answer, it will be visible if and only if the observable was the closest object the ray bumped into.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"public boolean canSee() {\\n    return observableFraction \u0026lt; 1.0f \u0026amp;\u0026amp; observableFraction \u0026lt;= minFraction;\\n}\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The system \", _jsx(_components.code, {\n        children: \"raycast()\"\n      }), \" method becomes very simple and can easily update the vision map.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"private void raycast(Entity entity, Entity target) {\\n    ObserverComponent observer = observerMapper.get(entity);\\n    ObservableComponent observable = observableMapper.get(target);\\n\\n    callback.prepare(entity, target);\\n\\n    world.rayCast(\\n        callback,\\n        observer.position,\\n        observable.position\\n    );\\n\\n    if (callback.canSee()) {\\n        addToVision(entity, target);\\n    }\\n    else {\\n        removeFromVision(entity, target);\\n    }\\n}\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"That's it, we have a nice, reusable vision system for any 2D game!\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Room for improvement\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Like I said, this is game jam code, you have been warned! Here's a few things I could think of to make the system more efficient and nicer in general.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Collision filtering: Box2D allows us to set bit masks to bodies to filter collisions. We can leverage that to select behind which bodies observables can hide.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Space partitioning: we can use a \", _jsx(_components.a, {\n          href: \"https://en.wikipedia.org/wiki/Quadtree\",\n          children: \"quadtree\"\n        }), \" to avoid processing every observable for each observer.\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Deferred raycasting: we probably don't need one frame accuracy, so we can update the vision maps for a subset of observers each frame. The player won't ever notice if that guard spotted him a couple of frames later.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Prioritisation: if you ever find yourself in a situation where there are just too many observables and observers you can add some sort of prioritisation to your deferred raycast queue, so the important ones get processed first. You may also have to keep track of the time spent in the queue to avoid starvation.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Some games may need slightly more complex vision models. For instance, you may add a small detection circle around observers to represent some kind of sixth sense. A guard would notice a presence right behind him after a short while. That would be quite easy to add to our \", _jsx(_components.code, {\n        children: \"VisionSystem\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/vision-system-alternate-model.webp\",\n      alt: \"vision-system-alternate-model.png\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Use it, improve it, give feedback\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Find the full source for the vision system here:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://github.com/dsaltares/libgdxjam/blob/master/core/src/com/siondream/libgdxjam/ecs/systems/VisionSystem.java\",\n          children: _jsx(_components.code, {\n            children: \"VisionSystem\"\n          })\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://github.com/dsaltares/libgdxjam/blob/master/core/src/com/siondream/libgdxjam/ecs/components/ObserverComponent.java\",\n          children: _jsx(_components.code, {\n            children: \"ObserverComponent\"\n          })\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://github.com/dsaltares/libgdxjam/blob/master/core/src/com/siondream/libgdxjam/ecs/components/ObservableComponent.java\",\n          children: _jsx(_components.code, {\n            children: \"ObservableComponent\"\n          })\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let me know what you think, especially if you use it. Would love some feedback on it!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","scope":{}},"series":null},"__N_SSG":true},"page":"/[slug]","query":{"slug":"2d-vision-system-with-ashley-and-box2d"},"buildId":"fjvCXZV6odoyGVI_9M9nM","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>