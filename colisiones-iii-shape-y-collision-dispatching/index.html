<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/touch-icon-144-precomposed.png"/><title>Colisiones III: Shape y Collision Dispatching · David Saltares</title><meta name="robots" content="index,follow"/><meta name="description" content="Engineering Leadership &amp; Software Development"/><meta property="og:title" content="Colisiones III: Shape y Collision Dispatching · David Saltares"/><meta property="og:description" content="Engineering Leadership &amp; Software Development"/><meta property="og:url" content="https://saltares.com/colisiones-iii-shape-y-collision-dispatching"/><meta property="og:type" content="website"/><link rel="canonical" href="https://saltares.com/colisiones-iii-shape-y-collision-dispatching"/><meta name="keywords" content=""/><meta name="next-head-count" content="12"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/_next/static/css/d3d4cc303d9c1080.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/d3d4cc303d9c1080.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-7671224c423a1e1f.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-66d32731bdd20e83.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-41a9ee3ebe735abe.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-75760b031d352622.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/c16184b3-5eed107b4bbcea31.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/2cca2479-0d4bcd71a6a0316a.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/252-2454d8293e83336b.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/167-6fe50976be6d0e53.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/962-ea29c7731d832d32.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/373-f5166c707bca4ed3.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/%5Bslug%5D-81b48131ea6e98cc.js" defer="" crossorigin=""></script><script src="/_next/static/iULNBwiNkeCtBlpT_6wiG/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/iULNBwiNkeCtBlpT_6wiG/_ssgManifest.js" defer="" crossorigin=""></script><style data-href="https://fonts.googleapis.com/css2?family=PT+Sans:wght@400;700&display=swap">@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/l/font?kit=jizaRExUiTo99u79P0Y&skey=fd0b32f0f3e6a1fc&v=v17) format('woff')}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/l/font?kit=jizfRExUiTo99u79B_mh4Oo&skey=a45e760d002c9b10&v=v17) format('woff')}@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79D0-ExcOPIDUg-g.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79D0aExcOPIDUg-g.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79D0yExcOPIDUg-g.woff2) format('woff2');unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79D0KExcOPIDU.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh0OOtLR8a8zILig.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh0OqtLR8a8zILig.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh0OCtLR8a8zILig.woff2) format('woff2');unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh0O6tLR8a8zI.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><div class="flex flex-col md:flex-row font-sans text-xl w-full"><aside class="md:max-w-[360px] bg-primary px-10 py-10 text-white text-xl md:fixed md:top-0 md:left-0 md:h-full flex flex-col justify-end items-center md:items-start"><div><a href="/"><div class="mb-5"><img alt="profile picture" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="rounded-full" style="color:transparent" src="/img/profile.webp"/></div><h1 class="text-white font-bold text-4xl leading-10">David Saltares</h1></a></div><p class="text-contentLight text-2xl mb-5 leading-9 text-center md:text-left">Engineering Leadership &amp; Software Development</p><div class="mb-5 font-base"><button class="ml-onclick-form" onclick="ml('show', '646AL4', true)">✉️ Subscribe</button></div><nav><ul class="mb-5 flex flex-col items-center md:items-start list-none pl-0"><li class="leading-7"><a href="/">Blog</a></li><li class="leading-7"><a href="/about-me/">About</a></li><li class="leading-7"><a href="/apps-tools/">Apps &amp; Tools</a></li><li class="leading-7"><a href="/game-jams/">Game Jams</a></li><li class="leading-7"><a href="/games/">Games</a></li><li class="leading-7"><a href="/libgdx-cross-platform-game-development-cookbook/">Libgdx Cookbook</a></li></ul></nav><ul class="mb-5 list-none pl-0"><li class="inline"><a aria-label="Github profile" href="https://github.com/dsaltares"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="square-github" class="svg-inline--fa fa-square-github text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM277.3 415.7c-8.4 1.5-11.5-3.7-11.5-8 0-5.4.2-33 .2-55.3 0-15.6-5.2-25.5-11.3-30.7 37-4.1 76-9.2 76-73.1 0-18.2-6.5-27.3-17.1-39 1.7-4.3 7.4-22-1.7-45-13.9-4.3-45.7 17.9-45.7 17.9-13.2-3.7-27.5-5.6-41.6-5.6-14.1 0-28.4 1.9-41.6 5.6 0 0-31.8-22.2-45.7-17.9-9.1 22.9-3.5 40.6-1.7 45-10.6 11.7-15.6 20.8-15.6 39 0 63.6 37.3 69 74.3 73.1-4.8 4.3-9.1 11.7-10.6 22.3-9.5 4.3-33.8 11.7-48.3-13.9-9.1-15.8-25.5-17.1-25.5-17.1-16.2-.2-1.1 10.2-1.1 10.2 10.8 5 18.4 24.2 18.4 24.2 9.7 29.7 56.1 19.7 56.1 19.7 0 13.9.2 36.5.2 40.6 0 4.3-3 9.5-11.5 8-66-22.1-112.2-84.9-112.2-158.3 0-91.8 70.2-161.5 162-161.5S388 165.6 388 257.4c.1 73.4-44.7 136.3-110.7 158.3zm-98.1-61.1c-1.9.4-3.7-.4-3.9-1.7-.2-1.5 1.1-2.8 3-3.2 1.9-.2 3.7.6 3.9 1.9.3 1.3-1 2.6-3 3zm-9.5-.9c0 1.3-1.5 2.4-3.5 2.4-2.2.2-3.7-.9-3.7-2.4 0-1.3 1.5-2.4 3.5-2.4 1.9-.2 3.7.9 3.7 2.4zm-13.7-1.1c-.4 1.3-2.4 1.9-4.1 1.3-1.9-.4-3.2-1.9-2.8-3.2.4-1.3 2.4-1.9 4.1-1.5 2 .6 3.3 2.1 2.8 3.4zm-12.3-5.4c-.9 1.1-2.8.9-4.3-.6-1.5-1.3-1.9-3.2-.9-4.1.9-1.1 2.8-.9 4.3.6 1.3 1.3 1.8 3.3.9 4.1zm-9.1-9.1c-.9.6-2.6 0-3.7-1.5s-1.1-3.2 0-3.9c1.1-.9 2.8-.2 3.7 1.3 1.1 1.5 1.1 3.3 0 4.1zm-6.5-9.7c-.9.9-2.4.4-3.5-.6-1.1-1.3-1.3-2.8-.4-3.5.9-.9 2.4-.4 3.5.6 1.1 1.3 1.3 2.8.4 3.5zm-6.7-7.4c-.4.9-1.7 1.1-2.8.4-1.3-.6-1.9-1.7-1.5-2.6.4-.6 1.5-.9 2.8-.4 1.3.7 1.9 1.8 1.5 2.6z"></path></svg></a></li><li class="inline"><a aria-label="Linkedin profile" href="https://www.linkedin.com/in/davidsaltares/"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="linkedin" class="svg-inline--fa fa-linkedin text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg></a></li><li class="inline"><a aria-label="Twitter profile" href="https://twitter.com/dsaltares"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="square-twitter" class="svg-inline--fa fa-square-twitter text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-48.9 158.8c.2 2.8.2 5.7.2 8.5 0 86.7-66 186.6-186.6 186.6-37.2 0-71.7-10.8-100.7-29.4 5.3.6 10.4.8 15.8.8 30.7 0 58.9-10.4 81.4-28-28.8-.6-53-19.5-61.3-45.5 10.1 1.5 19.2 1.5 29.6-1.2-30-6.1-52.5-32.5-52.5-64.4v-.8c8.7 4.9 18.9 7.9 29.6 8.3a65.447 65.447 0 0 1-29.2-54.6c0-12.2 3.2-23.4 8.9-33.1 32.3 39.8 80.8 65.8 135.2 68.6-9.3-44.5 24-80.6 64-80.6 18.9 0 35.9 7.9 47.9 20.7 14.8-2.8 29-8.3 41.6-15.8-4.9 15.2-15.2 28-28.8 36.1 13.2-1.4 26-5.1 37.8-10.2-8.9 13.1-20.1 24.7-32.9 34z"></path></svg></a></li><li class="inline"><a aria-label="RSS feed" href="https://saltares.com/index.xml"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="square-rss" class="svg-inline--fa fa-square-rss text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M64 32C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V96c0-35.3-28.7-64-64-64H64zM96 136c0-13.3 10.7-24 24-24c137 0 248 111 248 248c0 13.3-10.7 24-24 24s-24-10.7-24-24c0-110.5-89.5-200-200-200c-13.3 0-24-10.7-24-24zm0 96c0-13.3 10.7-24 24-24c83.9 0 152 68.1 152 152c0 13.3-10.7 24-24 24s-24-10.7-24-24c0-57.4-46.6-104-104-104c-13.3 0-24-10.7-24-24zm64 120c0 17.7-14.3 32-32 32s-32-14.3-32-32s14.3-32 32-32s32 14.3 32 32z"></path></svg></a></li><li class="inline"><a rel="me" href="https://fosstodon.org/@dsaltares"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="mastodon" class="svg-inline--fa fa-mastodon text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48 0 0 0-63.72 28.5-63.72 125.7 0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54 0 0 1-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"></path></svg></a></li></ul><p class="text-contentLight text-lg">© 2024 David Saltares.</p></aside><div class="md:max-w-[360px] w-full hidden md:block flex-grow-0 flex-shrink-0"></div><div class="flex flex-col main-content"><main class="w-full max-w-[720px] pr-4 py-10 pl-5 md:py-20 md:pl-20"><article class="text-content mb-10"><div><a href="/colisiones-iii-shape-y-collision-dispatching/"><h1 class="font-bold text-4xl mb-2 text-primary">Colisiones III: Shape y Collision Dispatching</h1></a><p class="flex text-contentLight mb-1">Feb 10 2011 · 6 min read<span> · </span><a class="text-contentLink" href="/colisiones-iii-shape-y-collision-dispatching/#disqus_thread">Comments</a></p><div class="mb-3"><div class="flex flex-row gap-1"><a class="px-2 py-1 bg-slate-900 text-white rounded font-bold text-sm" href="/categories/games-development/">Games development</a></div></div></div><img class="mb-1" src="/img/wp/colisiones-3.webp" alt="colisiones-3.png"/>
<p>Entregas</p>
<ul>
<li><a class="text-contentLink text-lg" href="/proyectos/pfc/sion-tower/colisiones-i-introduccion-requisitos-y-alternativas/">Colisiones I: Introducción, requisitos y alternativas</a></li>
<li><a class="text-contentLink text-lg" href="/proyectos/pfc/sion-tower/colisiones-ii-diseno-general-de-stc/">Colisiones II: Diseño general de STC</a></li>
<li>_Colisiones III: Shape y Collision Dispatching _</li>
</ul>
<p>Comenzamos la tercera entrega de la serie de artículos sobre **STC, el sistema de detección de colisiones de Sion Tower. En esta ocasión vamos a entrar en detalle en **la clase <em>Shape</em>, la encargada de modelar los volúmenes colisionables básicos entre otras tareas. Los tests de colisión entre formas concretas también pertenecen a esta clase pero por su complejidad los dejaremos para el siguiente artículo.</p>
<h3>La clase Shape</h3>
<p><em>Shape</em> es una clase abstracta y como tal no puede instanciarse directamente por lo que otros objetos han de heredar de ella e implementar los métodos convenientes. <em>Shape</em> modela un volumen geométrico genérico colisionable y está pensada para que todas sus implementaciones sean tratadas de manera uniforme.</p>
<img class="mb-1" src="/img/wp/shapes.webp" alt="shapes.png"/>
<h3>Collision Dispatching</h3>
<p>La clase <em>Shape</em> dispone de un método estático <em>getCollision</em> que recibe dos punteros a <em>Shape</em> y devuelve verdadero o falso en función de si se ha producido o no intersección. Internamente cuenta con otros métodos estáticos para detectar colisiones entre formas concretas, por ejemplo: la intersección entre una esfera y un AABB.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">class Shape {
public:

    ...

    static bool getCollision(Shape* shapeA, Shape* shapeB);

    ...

private:

    static bool getCollisionSphereSphere(Shape* shapeA, Shape* shapeB);
    static bool getCollisionAABBAABB(Shape* shapeA, Shape* shapeB);
    static bool getCollisionPlanePlane(Shape* shapeA, Shape* shapeB);
    static bool getCollisionSphereAABB(Shape* shapeA, Shape* shapeB);
    static bool getCollisionPlaneSphere(Shape* shapeA, Shape* shapeB);
    static bool getCollisionPlaneAABB(Shape* shapeA, Shape* shapeB);

};</code></pre></div>
<p>El <strong>Collision Dispatching</strong> es la tarea de seleccionar el test de colisión apropiado a partir de dos formas cuyo tipo desconocemos. En principio se podría pensar en emplear muchos bloques <em>if</em> con <em>dynamic_cast</em> capturando posibles excepciones para aseguramos de que seleccionamos los tipos apropiados. No obstante, ese tipo de casting son operaciones extremadamente costosas que no podemos permitirnos en un punto tan crítico como este. Estuve mucho tiempo dándole vueltas hasta dar con un sistema seguro, sencillo y eficiente de <a class="text-contentLink text-lg" href="http://en.wikibooks.org/wiki/C++_Programming/RTTI">RTTI</a>.</p>
<p>Es posible conocer la clase a la que pertenece una forma génerica incorporando un método virtual puro en <em>Shape</em>. Cada especialización está obligado a implementarlo, devolviendo un valor de un enumerado indicando su tipo.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">class Shape {
public:

    ...

    enum Type {SPHERE = 1, AABB = 2, PLANE = 3};

    virtual int getType() const = 0;

    ...
};

class Sphere {
public:

    ...

    int getType() const {return SPHERE;};

    ...
};</code></pre></div>
<p>Podemos tener una tabla estática que dados dos tipos de formas nos devuelva el método que efectúa el test de colisión entre ambas. En cada test de colisión se puede hacer un <em>static_cast</em> sin temor a encontrar con problemas ya que hemos comprobado el tipo con anterioridad. <em>static_cast</em> es mucho más rápido que <em>dynamic_cast</em> al no hacer comprobaciones.</p>
<p>No vamos a manejar punteros a función sino que <strong>haremos uso de las mágicas <em><a class="text-contentLink text-lg" href="http://www.boost.org/doc/libs/1_45_0/doc/html/function.html">boost::function</a></em> y <a class="text-contentLink text-lg" href="http://www.boost.org/doc/libs/1_45_0/libs/bind/bind.html"><em>boost:bind</em></a></strong>. Esto nos permitirá encapsular un método en un objeto y llamarlo posteriormente con el operador (). Si no conoces <a class="text-contentLink text-lg" href="http://www.boost.org/">Boost</a> deberías echarle un ojo ya que muchos de sus componentes <strong>entrarán en el próximo estándar de C++</strong>. El año pasado, mi compañero José Tomás Tocino impartió un taller de esta biblioteca, podéis encontrar los materiales <a class="text-contentLink text-lg" href="http://softwarelibre.uca.es:9001/redmine/repositories/show/taller-boost">aquí</a>. Para la tabla utilizaremos <em><a class="text-contentLink text-lg" href="http://www.boost.org/doc/libs/1_38_0/doc/html/boost/unordered_map.html">boost::unordered_map</a></em>, similar a <a class="text-contentLink text-lg" href="http://www.cppreference.com/wiki/container/map/start"><em>std::map</em></a> pero mucho más eficiente.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">class Sphere:
public:
    ...

    static void configureCollisionDispatching();

    ...

private:

    ...

    typedef boost::function&amp;lt;bool (Shape*, Shape*)&amp;gt; CollisionCheckFunction;
    typedef boost::unordered_map&amp;lt;int , boost::unordered_map&amp;lt;int, CollisionCheckFunction&amp;gt; &amp;gt; CollisionDispatchTable;

    static CollisionDispatchTable  _collisionDispatcher;
};</code></pre></div>
<p>El método <em>configureCollisionDispatching</em> se encarga de inicializar la tabla que asocia dos tipos con el método que implementa el test de colisión. Es necesario llamar a este método al comienzo de la aplicación aunque la clase <em>CollisionManager</em> ya lo hace por tí.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">void Shape::configureCollisionDispatching() {
    _collisionDispatcher[SPHERE][SPHERE] = boost::bind(&amp;amp;Shape::getCollisionSphereSphere, _1, _2);
    _collisionDispatcher[AABB][AABB] = boost::bind(&amp;amp;Shape::getCollisionAABBAABB, _1, _2);
    _collisionDispatcher[PLANE][PLANE] = boost::bind(&amp;amp;Shape::getCollisionPlanePlane, _1, _2);

    _collisionDispatcher[AABB][SPHERE] = boost::bind(&amp;amp;Shape::getCollisionSphereAABB, _1, _2);
    _collisionDispatcher[AABB][PLANE] = boost::bind(&amp;amp;Shape::getCollisionPlaneAABB, _1, _2);

    _collisionDispatcher[SPHERE][AABB] = boost::bind(&amp;amp;Shape::getCollisionSphereAABB, _1, _2);
    _collisionDispatcher[SPHERE][PLANE] = boost::bind(&amp;amp;Shape::getCollisionPlaneSphere, _1, _2);

    _collisionDispatcher[PLANE][AABB] = boost::bind(&amp;amp;Shape::getCollisionPlaneAABB, _1, _2);
    _collisionDispatcher[PLANE][SPHERE] = boost::bind(&amp;amp;Shape::getCollisionPlaneSphere, _1, _2);
}</code></pre></div>
<p>De esta forma <strong>conseguimos un Collision Dispatching muy eficiente, cómodo y extensible</strong>.</p>
<h3>Formas disponibles</h3>
<p>Como habréis deducido por los diagramas de clases, la versión 0.1 de STC incorpora <strong>tres tipos de formas diferentes</strong>: <em>Sphere</em>, <em>Plane</em> y <em>AxisAlignedBox</em>. A continuación vemos las distintas formas junto a su representación interna y un pequeño diagrama.</p>
<p>La <strong>esfera</strong> se representa por un punto (centro) y un real (radio) tal y como se muestra en el siguiente esquema. Es una forma sencilla que permite tests de colisión muy rápidos. Es muy común representar formas utilizando cuatro números reales ya que los chips gráficos están optimizados para hacer operaciones en paralelo con cuatro datos.</p>
<img class="mb-1" src="/img/wp/sphere.webp" alt="sphere.png"/>
<p>El <strong>plano</strong> está formado por un punto (distancia con respecto al origen) y un vector (normal o perpendicular a sí mismo). Podéis visualizarlo en el siguiente esquema.</p>
<img class="mb-1" src="/img/wp/plane.webp" alt="plane.png"/>
<p>Existen dos tipos de cajas: las <em>AxisAlignedBox</em> y las <em>OrientedBox</em>. Las primeras, como indica su nombre, siempre están alineadas con los ejes y no presentan rotación. En cambio, las segundas son volúmenes rotados. Las cajas alineadas con los ejes las representamos a través de dos puntos (mínimo y máximo) como podéis ver en el siguiente diagrama.</p>
<img class="mb-1" src="/img/wp/aabb.webp" alt="aabb.png"/>
<p>Las <em>AABB</em> ofrecen tests de colisión sencillos pero <strong>no funcionan bien con objetos que rotan</strong>. Al no poder rotar la caja debemos reajustarla con la consecuente pérdida de precisión, en algunos casos inaceptable. El siguiente esquema muestra a un coche y su <em>AABB</em> de colisión en ambos estados: sin rotar y tras ser rotado.</p>
<img class="mb-1" src="/img/wp/aabb-precission-loss.webp" alt="aabb-precission-loss.png"/>
<h3>Extendiendo la clase Shape</h3>
<p>Para crear nuevas formas sólo hay que elegir la representación deseada e implementar los siguientes métodos virtuales puros de la clase <em>Shape</em>:</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">class Shape {
public:
  virtual int getType() const = 0;
  virtual void applyTransform(
    Shape* localShape,
    const Ogre::Vector3&amp;amp; traslation = Ogre::Vector3::ZERO,
    const Ogre::Vector3&amp;amp; scale = Ogre::Vector3::UNIT_SCALE,
    const Ogre::Quaternion&amp;amp; orientation = Ogre::Quaternion::IDENTITY) = 0;
  virtual Shape* getTransformedCopy(
    const Ogre::Vector3&amp;amp; traslation = Ogre::Vector3::ZERO,
    const Ogre::Vector3&amp;amp; scale = Ogre::Vector3::UNIT_SCALE,
    const Ogre::Quaternion&amp;amp; orientation = Ogre::Quaternion::IDENTITY) = 0;
};</code></pre></div>
<p>El método <em>applyTransform</em> transforma la forma actual a partir de <em>localShape</em> incluyendo desplazamiento, escala y rotación. El método <em>getTransformedCopy</em> devuelve una copia de sí misma tras aplicar la transformación. Esto se utiliza para traducir formas de local space a world space. Deberás añadir los tests de colisión que desees y completar la inicialización de la tabla en el método <em>configureCollisionDispatching</em>. Puedo adelantar que para la versión 0.2 de STC (Sion Tower Collisions) estoy implementando la forma <em>OrientedBox</em> y sus correspondientes tests de colisión.</p>
<p>Hasta aquí la tercera entrega de los artículos sobre el sistema de detección de colisiones de Sion Tower.</p></article></main></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"metadata":{"path":"content/post/2011-02-10-colisiones-iii-shape-y-collision-dispatching.mdx","title":"Colisiones III: Shape y Collision Dispatching","date":"2011-02-10T18:59:44.000Z","categories":["Games development"],"series":null,"description":null,"slug":"colisiones-iii-shape-y-collision-dispatching","readingTime":"6 min read","draft":false,"disableComments":false,"keywords":[],"banner":null},"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    img: \"img\",\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    a: \"a\",\n    em: \"em\",\n    h3: \"h3\",\n    div: \"div\",\n    pre: \"pre\",\n    code: \"code\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.img, {\n      src: \"/img/wp/colisiones-3.webp\",\n      alt: \"colisiones-3.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Entregas\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/proyectos/pfc/sion-tower/colisiones-i-introduccion-requisitos-y-alternativas/\",\n          children: \"Colisiones I: Introducción, requisitos y alternativas\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/proyectos/pfc/sion-tower/colisiones-ii-diseno-general-de-stc/\",\n          children: \"Colisiones II: Diseño general de STC\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"_Colisiones III: Shape y Collision Dispatching _\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Comenzamos la tercera entrega de la serie de artículos sobre **STC, el sistema de detección de colisiones de Sion Tower. En esta ocasión vamos a entrar en detalle en **la clase \", _jsx(_components.em, {\n        children: \"Shape\"\n      }), \", la encargada de modelar los volúmenes colisionables básicos entre otras tareas. Los tests de colisión entre formas concretas también pertenecen a esta clase pero por su complejidad los dejaremos para el siguiente artículo.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"La clase Shape\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.em, {\n        children: \"Shape\"\n      }), \" es una clase abstracta y como tal no puede instanciarse directamente por lo que otros objetos han de heredar de ella e implementar los métodos convenientes. \", _jsx(_components.em, {\n        children: \"Shape\"\n      }), \" modela un volumen geométrico genérico colisionable y está pensada para que todas sus implementaciones sean tratadas de manera uniforme.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/shapes.webp\",\n      alt: \"shapes.png\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Collision Dispatching\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"La clase \", _jsx(_components.em, {\n        children: \"Shape\"\n      }), \" dispone de un método estático \", _jsx(_components.em, {\n        children: \"getCollision\"\n      }), \" que recibe dos punteros a \", _jsx(_components.em, {\n        children: \"Shape\"\n      }), \" y devuelve verdadero o falso en función de si se ha producido o no intersección. Internamente cuenta con otros métodos estáticos para detectar colisiones entre formas concretas, por ejemplo: la intersección entre una esfera y un AABB.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"class Shape {\\npublic:\\n\\n    ...\\n\\n    static bool getCollision(Shape* shapeA, Shape* shapeB);\\n\\n    ...\\n\\nprivate:\\n\\n    static bool getCollisionSphereSphere(Shape* shapeA, Shape* shapeB);\\n    static bool getCollisionAABBAABB(Shape* shapeA, Shape* shapeB);\\n    static bool getCollisionPlanePlane(Shape* shapeA, Shape* shapeB);\\n    static bool getCollisionSphereAABB(Shape* shapeA, Shape* shapeB);\\n    static bool getCollisionPlaneSphere(Shape* shapeA, Shape* shapeB);\\n    static bool getCollisionPlaneAABB(Shape* shapeA, Shape* shapeB);\\n\\n};\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"El \", _jsx(_components.strong, {\n        children: \"Collision Dispatching\"\n      }), \" es la tarea de seleccionar el test de colisión apropiado a partir de dos formas cuyo tipo desconocemos. En principio se podría pensar en emplear muchos bloques \", _jsx(_components.em, {\n        children: \"if\"\n      }), \" con \", _jsx(_components.em, {\n        children: \"dynamic_cast\"\n      }), \" capturando posibles excepciones para aseguramos de que seleccionamos los tipos apropiados. No obstante, ese tipo de casting son operaciones extremadamente costosas que no podemos permitirnos en un punto tan crítico como este. Estuve mucho tiempo dándole vueltas hasta dar con un sistema seguro, sencillo y eficiente de \", _jsx(_components.a, {\n        href: \"http://en.wikibooks.org/wiki/C++_Programming/RTTI\",\n        children: \"RTTI\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Es posible conocer la clase a la que pertenece una forma génerica incorporando un método virtual puro en \", _jsx(_components.em, {\n        children: \"Shape\"\n      }), \". Cada especialización está obligado a implementarlo, devolviendo un valor de un enumerado indicando su tipo.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"class Shape {\\npublic:\\n\\n    ...\\n\\n    enum Type {SPHERE = 1, AABB = 2, PLANE = 3};\\n\\n    virtual int getType() const = 0;\\n\\n    ...\\n};\\n\\nclass Sphere {\\npublic:\\n\\n    ...\\n\\n    int getType() const {return SPHERE;};\\n\\n    ...\\n};\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Podemos tener una tabla estática que dados dos tipos de formas nos devuelva el método que efectúa el test de colisión entre ambas. En cada test de colisión se puede hacer un \", _jsx(_components.em, {\n        children: \"static_cast\"\n      }), \" sin temor a encontrar con problemas ya que hemos comprobado el tipo con anterioridad. \", _jsx(_components.em, {\n        children: \"static_cast\"\n      }), \" es mucho más rápido que \", _jsx(_components.em, {\n        children: \"dynamic_cast\"\n      }), \" al no hacer comprobaciones.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"No vamos a manejar punteros a función sino que \", _jsxs(_components.strong, {\n        children: [\"haremos uso de las mágicas \", _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"http://www.boost.org/doc/libs/1_45_0/doc/html/function.html\",\n            children: \"boost::function\"\n          })\n        }), \" y \", _jsx(_components.a, {\n          href: \"http://www.boost.org/doc/libs/1_45_0/libs/bind/bind.html\",\n          children: _jsx(_components.em, {\n            children: \"boost:bind\"\n          })\n        })]\n      }), \". Esto nos permitirá encapsular un método en un objeto y llamarlo posteriormente con el operador (). Si no conoces \", _jsx(_components.a, {\n        href: \"http://www.boost.org/\",\n        children: \"Boost\"\n      }), \" deberías echarle un ojo ya que muchos de sus componentes \", _jsx(_components.strong, {\n        children: \"entrarán en el próximo estándar de C++\"\n      }), \". El año pasado, mi compañero José Tomás Tocino impartió un taller de esta biblioteca, podéis encontrar los materiales \", _jsx(_components.a, {\n        href: \"http://softwarelibre.uca.es:9001/redmine/repositories/show/taller-boost\",\n        children: \"aquí\"\n      }), \". Para la tabla utilizaremos \", _jsx(_components.em, {\n        children: _jsx(_components.a, {\n          href: \"http://www.boost.org/doc/libs/1_38_0/doc/html/boost/unordered_map.html\",\n          children: \"boost::unordered_map\"\n        })\n      }), \", similar a \", _jsx(_components.a, {\n        href: \"http://www.cppreference.com/wiki/container/map/start\",\n        children: _jsx(_components.em, {\n          children: \"std::map\"\n        })\n      }), \" pero mucho más eficiente.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"class Sphere:\\npublic:\\n    ...\\n\\n    static void configureCollisionDispatching();\\n\\n    ...\\n\\nprivate:\\n\\n    ...\\n\\n    typedef boost::function\u0026lt;bool (Shape*, Shape*)\u0026gt; CollisionCheckFunction;\\n    typedef boost::unordered_map\u0026lt;int , boost::unordered_map\u0026lt;int, CollisionCheckFunction\u0026gt; \u0026gt; CollisionDispatchTable;\\n\\n    static CollisionDispatchTable  _collisionDispatcher;\\n};\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"El método \", _jsx(_components.em, {\n        children: \"configureCollisionDispatching\"\n      }), \" se encarga de inicializar la tabla que asocia dos tipos con el método que implementa el test de colisión. Es necesario llamar a este método al comienzo de la aplicación aunque la clase \", _jsx(_components.em, {\n        children: \"CollisionManager\"\n      }), \" ya lo hace por tí.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"void Shape::configureCollisionDispatching() {\\n    _collisionDispatcher[SPHERE][SPHERE] = boost::bind(\u0026amp;Shape::getCollisionSphereSphere, _1, _2);\\n    _collisionDispatcher[AABB][AABB] = boost::bind(\u0026amp;Shape::getCollisionAABBAABB, _1, _2);\\n    _collisionDispatcher[PLANE][PLANE] = boost::bind(\u0026amp;Shape::getCollisionPlanePlane, _1, _2);\\n\\n    _collisionDispatcher[AABB][SPHERE] = boost::bind(\u0026amp;Shape::getCollisionSphereAABB, _1, _2);\\n    _collisionDispatcher[AABB][PLANE] = boost::bind(\u0026amp;Shape::getCollisionPlaneAABB, _1, _2);\\n\\n    _collisionDispatcher[SPHERE][AABB] = boost::bind(\u0026amp;Shape::getCollisionSphereAABB, _1, _2);\\n    _collisionDispatcher[SPHERE][PLANE] = boost::bind(\u0026amp;Shape::getCollisionPlaneSphere, _1, _2);\\n\\n    _collisionDispatcher[PLANE][AABB] = boost::bind(\u0026amp;Shape::getCollisionPlaneAABB, _1, _2);\\n    _collisionDispatcher[PLANE][SPHERE] = boost::bind(\u0026amp;Shape::getCollisionPlaneSphere, _1, _2);\\n}\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"De esta forma \", _jsx(_components.strong, {\n        children: \"conseguimos un Collision Dispatching muy eficiente, cómodo y extensible\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Formas disponibles\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Como habréis deducido por los diagramas de clases, la versión 0.1 de STC incorpora \", _jsx(_components.strong, {\n        children: \"tres tipos de formas diferentes\"\n      }), \": \", _jsx(_components.em, {\n        children: \"Sphere\"\n      }), \", \", _jsx(_components.em, {\n        children: \"Plane\"\n      }), \" y \", _jsx(_components.em, {\n        children: \"AxisAlignedBox\"\n      }), \". A continuación vemos las distintas formas junto a su representación interna y un pequeño diagrama.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"La \", _jsx(_components.strong, {\n        children: \"esfera\"\n      }), \" se representa por un punto (centro) y un real (radio) tal y como se muestra en el siguiente esquema. Es una forma sencilla que permite tests de colisión muy rápidos. Es muy común representar formas utilizando cuatro números reales ya que los chips gráficos están optimizados para hacer operaciones en paralelo con cuatro datos.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/sphere.webp\",\n      alt: \"sphere.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"El \", _jsx(_components.strong, {\n        children: \"plano\"\n      }), \" está formado por un punto (distancia con respecto al origen) y un vector (normal o perpendicular a sí mismo). Podéis visualizarlo en el siguiente esquema.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/plane.webp\",\n      alt: \"plane.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Existen dos tipos de cajas: las \", _jsx(_components.em, {\n        children: \"AxisAlignedBox\"\n      }), \" y las \", _jsx(_components.em, {\n        children: \"OrientedBox\"\n      }), \". Las primeras, como indica su nombre, siempre están alineadas con los ejes y no presentan rotación. En cambio, las segundas son volúmenes rotados. Las cajas alineadas con los ejes las representamos a través de dos puntos (mínimo y máximo) como podéis ver en el siguiente diagrama.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/aabb.webp\",\n      alt: \"aabb.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Las \", _jsx(_components.em, {\n        children: \"AABB\"\n      }), \" ofrecen tests de colisión sencillos pero \", _jsx(_components.strong, {\n        children: \"no funcionan bien con objetos que rotan\"\n      }), \". Al no poder rotar la caja debemos reajustarla con la consecuente pérdida de precisión, en algunos casos inaceptable. El siguiente esquema muestra a un coche y su \", _jsx(_components.em, {\n        children: \"AABB\"\n      }), \" de colisión en ambos estados: sin rotar y tras ser rotado.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/aabb-precission-loss.webp\",\n      alt: \"aabb-precission-loss.png\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Extendiendo la clase Shape\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Para crear nuevas formas sólo hay que elegir la representación deseada e implementar los siguientes métodos virtuales puros de la clase \", _jsx(_components.em, {\n        children: \"Shape\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"class Shape {\\npublic:\\n  virtual int getType() const = 0;\\n  virtual void applyTransform(\\n    Shape* localShape,\\n    const Ogre::Vector3\u0026amp; traslation = Ogre::Vector3::ZERO,\\n    const Ogre::Vector3\u0026amp; scale = Ogre::Vector3::UNIT_SCALE,\\n    const Ogre::Quaternion\u0026amp; orientation = Ogre::Quaternion::IDENTITY) = 0;\\n  virtual Shape* getTransformedCopy(\\n    const Ogre::Vector3\u0026amp; traslation = Ogre::Vector3::ZERO,\\n    const Ogre::Vector3\u0026amp; scale = Ogre::Vector3::UNIT_SCALE,\\n    const Ogre::Quaternion\u0026amp; orientation = Ogre::Quaternion::IDENTITY) = 0;\\n};\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"El método \", _jsx(_components.em, {\n        children: \"applyTransform\"\n      }), \" transforma la forma actual a partir de \", _jsx(_components.em, {\n        children: \"localShape\"\n      }), \" incluyendo desplazamiento, escala y rotación. El método \", _jsx(_components.em, {\n        children: \"getTransformedCopy\"\n      }), \" devuelve una copia de sí misma tras aplicar la transformación. Esto se utiliza para traducir formas de local space a world space. Deberás añadir los tests de colisión que desees y completar la inicialización de la tabla en el método \", _jsx(_components.em, {\n        children: \"configureCollisionDispatching\"\n      }), \". Puedo adelantar que para la versión 0.2 de STC (Sion Tower Collisions) estoy implementando la forma \", _jsx(_components.em, {\n        children: \"OrientedBox\"\n      }), \" y sus correspondientes tests de colisión.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Hasta aquí la tercera entrega de los artículos sobre el sistema de detección de colisiones de Sion Tower.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","scope":{}},"series":null},"__N_SSG":true},"page":"/[slug]","query":{"slug":"colisiones-iii-shape-y-collision-dispatching"},"buildId":"iULNBwiNkeCtBlpT_6wiG","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>