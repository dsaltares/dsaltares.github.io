<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/touch-icon-144-precomposed.png"/><title>ListenerSet using variadic templates · David Saltares</title><meta name="robots" content="index,follow"/><meta name="description" content="Engineering Leadership &amp; Software Development"/><meta property="og:title" content="ListenerSet using variadic templates · David Saltares"/><meta property="og:description" content="Engineering Leadership &amp; Software Development"/><meta property="og:url" content="https://saltares.com/listenerset-using-variadic-templates"/><meta property="og:type" content="website"/><link rel="canonical" href="https://saltares.com/listenerset-using-variadic-templates"/><meta name="keywords" content=""/><meta name="next-head-count" content="12"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/_next/static/css/1e80e7c82199c580.css" as="style"/><link rel="stylesheet" href="/_next/static/css/1e80e7c82199c580.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-24470d78cf61f77f.js" defer=""></script><script src="/_next/static/chunks/framework-9b5d6ec4444c80fa.js" defer=""></script><script src="/_next/static/chunks/main-e42aac98337d61c6.js" defer=""></script><script src="/_next/static/chunks/pages/_app-89283805d41ea493.js" defer=""></script><script src="/_next/static/chunks/c16184b3-9b756f0214555638.js" defer=""></script><script src="/_next/static/chunks/2cca2479-c0f2c9f2f2dc1702.js" defer=""></script><script src="/_next/static/chunks/252-64d0c1a5eecbfabd.js" defer=""></script><script src="/_next/static/chunks/167-7d296999b3b0013a.js" defer=""></script><script src="/_next/static/chunks/962-68c39fb6207889be.js" defer=""></script><script src="/_next/static/chunks/673-8982310ab2fdaad5.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bslug%5D-d0bad99a4f6f3b56.js" defer=""></script><script src="/_next/static/tqJOQD0pEW5bmwVi0mnQc/_buildManifest.js" defer=""></script><script src="/_next/static/tqJOQD0pEW5bmwVi0mnQc/_ssgManifest.js" defer=""></script><style data-href="https://fonts.googleapis.com/css2?family=PT+Sans:wght@400;700&display=swap">@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79P0Y.woff) format('woff')}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh4Oo.woff) format('woff')}@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79D0-ExcOPIDUg-g.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79D0aExcOPIDUg-g.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79D0yExcOPIDUg-g.woff2) format('woff2');unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'PT Sans';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizaRExUiTo99u79D0KExcOPIDU.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh0OOtLR8a8zILig.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh0OqtLR8a8zILig.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh0OCtLR8a8zILig.woff2) format('woff2');unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'PT Sans';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/ptsans/v17/jizfRExUiTo99u79B_mh0O6tLR8a8zI.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><div class="flex flex-col md:flex-row font-sans text-xl w-full"><aside class="md:max-w-[360px] bg-primary px-10 py-10 text-white text-xl md:fixed md:top-0 md:left-0 md:h-full flex flex-col justify-end items-center md:items-start"><div><a href="/"><div class="mb-5"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27200%27%20height=%27200%27/%3e"/></span><img alt="profile picture" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="rounded-full" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="profile picture" src="/img/profile.webp" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" class="rounded-full" loading="lazy"/></noscript></span></div><h1 class="text-white font-bold text-4xl leading-10">David Saltares</h1></a></div><p class="text-contentLight text-2xl mb-5 leading-9 text-center md:text-left">Engineering Leadership &amp; Software Development</p><a href="https://tinyletter.com/dsaltares/"><p class="mb-5">✉️ Subscribe</p></a><nav><ul class="mb-5 flex flex-col items-center md:items-start list-none pl-0"><li class="leading-7"><a href="/">Blog</a></li><li class="leading-7"><a href="/about-me/">About</a></li><li class="leading-7"><a href="/apps-tools/">Apps &amp; Tools</a></li><li class="leading-7"><a href="/game-jams/">Game Jams</a></li><li class="leading-7"><a href="/games/">Games</a></li><li class="leading-7"><a href="/libgdx-cross-platform-game-development-cookbook/">Libgdx Cookbook</a></li></ul></nav><ul class="mb-5 list-none pl-0"><li class="inline"><a aria-label="Github profile" href="https://github.com/dsaltares"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="square-github" class="svg-inline--fa fa-square-github text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM277.3 415.7c-8.4 1.5-11.5-3.7-11.5-8 0-5.4.2-33 .2-55.3 0-15.6-5.2-25.5-11.3-30.7 37-4.1 76-9.2 76-73.1 0-18.2-6.5-27.3-17.1-39 1.7-4.3 7.4-22-1.7-45-13.9-4.3-45.7 17.9-45.7 17.9-13.2-3.7-27.5-5.6-41.6-5.6-14.1 0-28.4 1.9-41.6 5.6 0 0-31.8-22.2-45.7-17.9-9.1 22.9-3.5 40.6-1.7 45-10.6 11.7-15.6 20.8-15.6 39 0 63.6 37.3 69 74.3 73.1-4.8 4.3-9.1 11.7-10.6 22.3-9.5 4.3-33.8 11.7-48.3-13.9-9.1-15.8-25.5-17.1-25.5-17.1-16.2-.2-1.1 10.2-1.1 10.2 10.8 5 18.4 24.2 18.4 24.2 9.7 29.7 56.1 19.7 56.1 19.7 0 13.9.2 36.5.2 40.6 0 4.3-3 9.5-11.5 8-66-22.1-112.2-84.9-112.2-158.3 0-91.8 70.2-161.5 162-161.5S388 165.6 388 257.4c.1 73.4-44.7 136.3-110.7 158.3zm-98.1-61.1c-1.9.4-3.7-.4-3.9-1.7-.2-1.5 1.1-2.8 3-3.2 1.9-.2 3.7.6 3.9 1.9.3 1.3-1 2.6-3 3zm-9.5-.9c0 1.3-1.5 2.4-3.5 2.4-2.2.2-3.7-.9-3.7-2.4 0-1.3 1.5-2.4 3.5-2.4 1.9-.2 3.7.9 3.7 2.4zm-13.7-1.1c-.4 1.3-2.4 1.9-4.1 1.3-1.9-.4-3.2-1.9-2.8-3.2.4-1.3 2.4-1.9 4.1-1.5 2 .6 3.3 2.1 2.8 3.4zm-12.3-5.4c-.9 1.1-2.8.9-4.3-.6-1.5-1.3-1.9-3.2-.9-4.1.9-1.1 2.8-.9 4.3.6 1.3 1.3 1.8 3.3.9 4.1zm-9.1-9.1c-.9.6-2.6 0-3.7-1.5s-1.1-3.2 0-3.9c1.1-.9 2.8-.2 3.7 1.3 1.1 1.5 1.1 3.3 0 4.1zm-6.5-9.7c-.9.9-2.4.4-3.5-.6-1.1-1.3-1.3-2.8-.4-3.5.9-.9 2.4-.4 3.5.6 1.1 1.3 1.3 2.8.4 3.5zm-6.7-7.4c-.4.9-1.7 1.1-2.8.4-1.3-.6-1.9-1.7-1.5-2.6.4-.6 1.5-.9 2.8-.4 1.3.7 1.9 1.8 1.5 2.6z"></path></svg></a></li><li class="inline"><a aria-label="Linkedin profile" href="https://www.linkedin.com/in/davidsaltares/"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="linkedin" class="svg-inline--fa fa-linkedin text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg></a></li><li class="inline"><a aria-label="Twitter profile" href="https://twitter.com/dsaltares"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="square-twitter" class="svg-inline--fa fa-square-twitter text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-48.9 158.8c.2 2.8.2 5.7.2 8.5 0 86.7-66 186.6-186.6 186.6-37.2 0-71.7-10.8-100.7-29.4 5.3.6 10.4.8 15.8.8 30.7 0 58.9-10.4 81.4-28-28.8-.6-53-19.5-61.3-45.5 10.1 1.5 19.2 1.5 29.6-1.2-30-6.1-52.5-32.5-52.5-64.4v-.8c8.7 4.9 18.9 7.9 29.6 8.3a65.447 65.447 0 0 1-29.2-54.6c0-12.2 3.2-23.4 8.9-33.1 32.3 39.8 80.8 65.8 135.2 68.6-9.3-44.5 24-80.6 64-80.6 18.9 0 35.9 7.9 47.9 20.7 14.8-2.8 29-8.3 41.6-15.8-4.9 15.2-15.2 28-28.8 36.1 13.2-1.4 26-5.1 37.8-10.2-8.9 13.1-20.1 24.7-32.9 34z"></path></svg></a></li><li class="inline"><a aria-label="RSS feed" href="https://saltares.com/index.xml"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="square-rss" class="svg-inline--fa fa-square-rss text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M64 32C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V96c0-35.3-28.7-64-64-64H64zM96 136c0-13.3 10.7-24 24-24c137 0 248 111 248 248c0 13.3-10.7 24-24 24s-24-10.7-24-24c0-110.5-89.5-200-200-200c-13.3 0-24-10.7-24-24zm0 96c0-13.3 10.7-24 24-24c83.9 0 152 68.1 152 152c0 13.3-10.7 24-24 24s-24-10.7-24-24c0-57.4-46.6-104-104-104c-13.3 0-24-10.7-24-24zm64 120c0 17.7-14.3 32-32 32s-32-14.3-32-32s14.3-32 32-32s32 14.3 32 32z"></path></svg></a></li><li class="inline"><a rel="me" href="https://fosstodon.org/@dsaltares"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="mastodon" class="svg-inline--fa fa-mastodon text-4xl mr-2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48 0 0 0-63.72 28.5-63.72 125.7 0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54 0 0 1-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"></path></svg></a></li></ul><p class="text-contentLight text-lg">© 2023 David Saltares.</p></aside><div class="md:max-w-[360px] w-full hidden md:block flex-grow-0 flex-shrink-0"></div><div class="flex flex-col main-content"><main class="w-full max-w-[720px] pr-4 py-10 pl-5 md:py-20 md:pl-20"><article class="text-content mb-10"><div><a href="/listenerset-using-variadic-templates/"><h1 class="font-bold text-4xl mb-2 text-primary">ListenerSet using variadic templates</h1></a><p class="flex text-contentLight mb-1">Apr 24 2014 · 5 min read<span> · </span><a class="text-contentLink" href="/listenerset-using-variadic-templates/#disqus_thread">Comments</a></p><div class="mb-3"><div class="flex flex-row gap-1"><a class="px-2 py-1 bg-slate-900 text-white rounded font-bold text-sm" href="/categories/computing/">Computing</a></div></div></div><p><strong>Important</strong>: variadic templates are only available from C++11, make sure your compiler supports it.</p>
<p>Who has never used the <a class="text-contentLink text-lg" href="http://en.wikipedia.org/wiki/Observer_pattern">Observer</a> pattern? As long as you have been involved in any medium sized project, chances are you have come across it at some point.</p>
<h3>The problem</h3>
<p>It is extremely common to have an event generating system other components would like to subscribe to. However, oftentimes I see code to manage a collection of listeners being unnecessarily duplicated on a per system basis. That is registration, un-registration and notification. A lot of nonsensical boilerplate, which makes for code that is harder to read and easier to get wrong.</p>
<p>Let&#x27;s take a look at a typical input event dispatching system, simplified for the purposes of this article. We could have an <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">IInputListener</code> interface that handles a couple of events, <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">keyDown()</code> and <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">keyUp()</code>.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">struct IInputListener
{
    virtual ~IInputListener() {}
    virtual bool keyDown(KeyCode code) = 0;
    virtual bool keyUp(KeyCode code) = 0;
};</code></pre></div>
<p>Our <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">InputSystem</code> class could hold an <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">std::set</code> of <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">IInputListener</code> pointers. Registration and un-registration is made possible through <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">addListener()</code> and <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">removeListener()</code> respectively. Bad news is that, every single time we want to send an event to the listeners, we are forced to iterate over the collection. Also, God kills a kitten.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">class InputSystem
{
public:
    void addListener(IInputListener* listener)
    {
        m_listeners.insert(listener);
    }

    void removeListener(IInputListener* listener)
    {
        m_listeners.erase(listener);
    }

    void update()
    {
        // Touch down detected
        for (auto listener : m_listeners)
        {
            listener-&amp;gt;keyDown(code);
        }

        ...

        // Touch up detected
        for (auto listener : m_listeners)
        {
            listener-&amp;gt;keyUp(code);
        }
    }

private:
    std::set&amp;lt;IInputListener*&amp;gt; m_listeners;
};</code></pre></div>
<p>As if this wasn&#x27;t enough, there is another important <em>gotcha</em> here. What happens when a listener un-registers as a result of an event? The <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">m_listeners</code> collection is modified in the middle of the <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">for</code> loop, thus current iterators are no longer valid. The second we try to increment the internal iterator to fetch the next listener.</p>
<blockquote>
<p>BAM!</p>
</blockquote>
<p>Not good.</p>
<p>The solution is simple but annoying. We can just add new listener registration and un-registration requests to a pending list while in the middle of a dispatch. Those pending lists would be processed once it&#x27;s safe to modify the collection of listeners.</p>
<p>Moreover, some people use <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">std::vector</code> instead of <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">std::set</code> for performance reasons, which is completely legit. However, that involves adding code to ensure listener uniqueness in the collection.</p>
<p>Every time.</p>
<p>Honestly? I&#x27;m lazy so I don&#x27;t want to be the guy who implements this over and over.</p>
<blockquote>
<p>Okay, so what do you suggest?</p>
</blockquote>
<h3>The way towards the solution</h3>
<p>Following our intuition, we realise that a way to generalise this behaviour is in order. Ideally, it would meet the following criteria.</p>
<ul>
<li>Avoids all code duplication.</li>
<li>Ensures listener uniqueness.</li>
<li>It is safe, can register, un-register while notifying.</li>
<li>Avoids manually going through the listener collection to send an event.</li>
<li>Compatible with any kind of event listener.</li>
</ul>
<p>Intuitively, we could have a <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">ListenerSet&lt;Type&gt;</code> template class that handles listener duplication as well as registration and un-registration safety.</p>
<p><strong>Note</strong>: we&#x27;ll be using <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">std::set</code> rather than <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">std::vector</code> for simplicity. Both can be used as long as the appropriate precautions are taken.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">template &amp;lt;class Type&amp;gt; class ListenerSet
{
public:
    ListenerSet() {}
    virtual ~ListenerSet() {}

    inline void addListener(Type listener)
    {
        if (m_notifying)
        {
            m_pendingAddition.insert(listener);
            m_pendingRemoval.erase(listener);
        }
        else
        {
            m_listeners.insert(listener);
        }
    }

    inline void removeListener(Type listener)
    {
        if (m_notifying)
        {
            m_pendingRemoval.insert(listener);
            m_pendingAddition.erase(listener);
        }
        else
        {
            m_listeners.erase(listener);
        }
    }

private:
    bool m_notifying;
    std::set&amp;lt;Type&amp;gt; m_pendingRemoval;
    std::set&amp;lt;Type&amp;gt; m_pendingAddition;
    std::set&amp;lt;Type&amp;gt; m_listeners;
};</code></pre></div>
<p>We&#x27;re missing the notification functionality, that&#x27;s the tricky part. We would like to have an interface such as to be able to do something like this.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">m_listenerSet.notify(&amp;amp;IInputListener::keyDown, keyCode);</code></pre></div>
<p><code class="text-code bg-codeBg px-2 py-1 text-sm rounded">ListenerSet::notify()</code> would iterate over all the registered listeners calling <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">IInputListener::keyDown</code> and passing <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">keyCode</code> as a parameter.</p>
<blockquote>
<p>Maybe easier said than done?</p>
</blockquote>
<p>True, <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">ListenerSet::notify()</code> needs to support an arbitrary number of arguments, as different event handlers won&#x27;t necessarily have the same signature. Moreover, <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">IInputListener::keyDown</code>(and every other potential handler) needs to receive a <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">this</code> pointer along the remaining arguments.</p>
<p>This is where <a class="text-contentLink text-lg" href="http://www.cplusplus.com/articles/EhvU7k9E/">variadic templates</a> come into play. Basically, they&#x27;re templates that can take an arbitrary number of parameters of any type.</p>
<p>Interestingly enough, <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">std::bind()</code> also takes an arbitrary number of parameters. That means we can create an <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">std::function&gt;</code> object that has everything we need: the event handler function pointer, <code class="text-code bg-codeBg px-2 py-1 text-sm rounded">this</code> and the remaining arguments.</p>
<p>Take a look at the code.</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">template &amp;lt;class Function, class... Arguments&amp;gt;
inline void notify(Function&amp;amp;&amp;amp; f, Arguments&amp;amp;&amp;amp;... args)
{
    m_notifying = true;
    for (Type listener : m_listeners)
    {
        auto callback = std::bind(f, listener, args...);
        callback(listener);
    }
    m_notifying = false;

    for (Type listener : m_pendingRemoval)
    {
        m_listeners.erase(listener);
    }

    m_pendingRemoval.clear();

    for (Type listener : m_pendingAddition)
    {
        m_listeners.insert(listener);
    }

    m_pendingAddition.clear();
}</code></pre></div>
<p>Note how we process the pending requests to add or remove listeners after we finish sending the events, that&#x27;s when it&#x27;s safe.</p>
<p>Now we can do exactly what we wanted!</p>
<div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">ListenerSet&amp;lt;IInputListener*&amp;gt; listeners;

listeners.addListener(new PlayerInputListener());
listeners.addListener(new UserInterfaceInputListener());

m_listenerSet.notify(&amp;amp;IInputListener::keyDown, keyCode);
m_listenerSet.notify(&amp;amp;IInputListener::keyUp, keyCode);</code></pre></div>
<p>Templates are instantiated at compile time, which means the compiler will complain if we&#x27;re doing something dodgy such as trying to bind the wrong thing. Compile time checks are good.</p>
<p>Managing a set of listeners and sending events is now a lot easier, safer and readable. Last but not least, it&#x27;s significantly less error prone.</p>
<blockquote>
<p>Hooray!!!</p>
</blockquote>
<h3>Full source</h3>
<p>For those interested, I&#x27;ve made the code available as a GitHub Gist.</p>
<p><a class="text-contentLink text-lg" href="https://gist.github.com/dsaltares/11212605">ListenerSet implementation</a></p></article></main></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metadata":{"path":"content/post/2014-04-24-listenerset-using-variadic-templates.mdx","title":"ListenerSet using variadic templates","date":"2014-04-24T10:00:02.000Z","categories":["Computing"],"series":null,"description":null,"slug":"listenerset-using-variadic-templates","readingTime":"5 min read","draft":false,"disableComments":false,"keywords":[],"banner":null},"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    strong: \"strong\",\n    a: \"a\",\n    h3: \"h3\",\n    code: \"code\",\n    div: \"div\",\n    pre: \"pre\",\n    em: \"em\",\n    blockquote: \"blockquote\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Important\"\n      }), \": variadic templates are only available from C++11, make sure your compiler supports it.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Who has never used the \", _jsx(_components.a, {\n        href: \"http://en.wikipedia.org/wiki/Observer_pattern\",\n        children: \"Observer\"\n      }), \" pattern? As long as you have been involved in any medium sized project, chances are you have come across it at some point.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"The problem\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It is extremely common to have an event generating system other components would like to subscribe to. However, oftentimes I see code to manage a collection of listeners being unnecessarily duplicated on a per system basis. That is registration, un-registration and notification. A lot of nonsensical boilerplate, which makes for code that is harder to read and easier to get wrong.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let's take a look at a typical input event dispatching system, simplified for the purposes of this article. We could have an \", _jsx(_components.code, {\n        children: \"IInputListener\"\n      }), \" interface that handles a couple of events, \", _jsx(_components.code, {\n        children: \"keyDown()\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"keyUp()\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"struct IInputListener\\n{\\n    virtual ~IInputListener() {}\\n    virtual bool keyDown(KeyCode code) = 0;\\n    virtual bool keyUp(KeyCode code) = 0;\\n};\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Our \", _jsx(_components.code, {\n        children: \"InputSystem\"\n      }), \" class could hold an \", _jsx(_components.code, {\n        children: \"std::set\"\n      }), \" of \", _jsx(_components.code, {\n        children: \"IInputListener\"\n      }), \" pointers. Registration and un-registration is made possible through \", _jsx(_components.code, {\n        children: \"addListener()\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"removeListener()\"\n      }), \" respectively. Bad news is that, every single time we want to send an event to the listeners, we are forced to iterate over the collection. Also, God kills a kitten.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"class InputSystem\\n{\\npublic:\\n    void addListener(IInputListener* listener)\\n    {\\n        m_listeners.insert(listener);\\n    }\\n\\n    void removeListener(IInputListener* listener)\\n    {\\n        m_listeners.erase(listener);\\n    }\\n\\n    void update()\\n    {\\n        // Touch down detected\\n        for (auto listener : m_listeners)\\n        {\\n            listener-\u0026gt;keyDown(code);\\n        }\\n\\n        ...\\n\\n        // Touch up detected\\n        for (auto listener : m_listeners)\\n        {\\n            listener-\u0026gt;keyUp(code);\\n        }\\n    }\\n\\nprivate:\\n    std::set\u0026lt;IInputListener*\u0026gt; m_listeners;\\n};\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As if this wasn't enough, there is another important \", _jsx(_components.em, {\n        children: \"gotcha\"\n      }), \" here. What happens when a listener un-registers as a result of an event? The \", _jsx(_components.code, {\n        children: \"m_listeners\"\n      }), \" collection is modified in the middle of the \", _jsx(_components.code, {\n        children: \"for\"\n      }), \" loop, thus current iterators are no longer valid. The second we try to increment the internal iterator to fetch the next listener.\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"BAM!\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Not good.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The solution is simple but annoying. We can just add new listener registration and un-registration requests to a pending list while in the middle of a dispatch. Those pending lists would be processed once it's safe to modify the collection of listeners.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Moreover, some people use \", _jsx(_components.code, {\n        children: \"std::vector\"\n      }), \" instead of \", _jsx(_components.code, {\n        children: \"std::set\"\n      }), \" for performance reasons, which is completely legit. However, that involves adding code to ensure listener uniqueness in the collection.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Every time.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Honestly? I'm lazy so I don't want to be the guy who implements this over and over.\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"Okay, so what do you suggest?\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"The way towards the solution\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Following our intuition, we realise that a way to generalise this behaviour is in order. Ideally, it would meet the following criteria.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Avoids all code duplication.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Ensures listener uniqueness.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"It is safe, can register, un-register while notifying.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Avoids manually going through the listener collection to send an event.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Compatible with any kind of event listener.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Intuitively, we could have a \", _jsx(_components.code, {\n        children: \"ListenerSet\u003cType\u003e\"\n      }), \" template class that handles listener duplication as well as registration and un-registration safety.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Note\"\n      }), \": we'll be using \", _jsx(_components.code, {\n        children: \"std::set\"\n      }), \" rather than \", _jsx(_components.code, {\n        children: \"std::vector\"\n      }), \" for simplicity. Both can be used as long as the appropriate precautions are taken.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"template \u0026lt;class Type\u0026gt; class ListenerSet\\n{\\npublic:\\n    ListenerSet() {}\\n    virtual ~ListenerSet() {}\\n\\n    inline void addListener(Type listener)\\n    {\\n        if (m_notifying)\\n        {\\n            m_pendingAddition.insert(listener);\\n            m_pendingRemoval.erase(listener);\\n        }\\n        else\\n        {\\n            m_listeners.insert(listener);\\n        }\\n    }\\n\\n    inline void removeListener(Type listener)\\n    {\\n        if (m_notifying)\\n        {\\n            m_pendingRemoval.insert(listener);\\n            m_pendingAddition.erase(listener);\\n        }\\n        else\\n        {\\n            m_listeners.erase(listener);\\n        }\\n    }\\n\\nprivate:\\n    bool m_notifying;\\n    std::set\u0026lt;Type\u0026gt; m_pendingRemoval;\\n    std::set\u0026lt;Type\u0026gt; m_pendingAddition;\\n    std::set\u0026lt;Type\u0026gt; m_listeners;\\n};\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We're missing the notification functionality, that's the tricky part. We would like to have an interface such as to be able to do something like this.\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"m_listenerSet.notify(\u0026amp;IInputListener::keyDown, keyCode);\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"ListenerSet::notify()\"\n      }), \" would iterate over all the registered listeners calling \", _jsx(_components.code, {\n        children: \"IInputListener::keyDown\"\n      }), \" and passing \", _jsx(_components.code, {\n        children: \"keyCode\"\n      }), \" as a parameter.\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"Maybe easier said than done?\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"True, \", _jsx(_components.code, {\n        children: \"ListenerSet::notify()\"\n      }), \" needs to support an arbitrary number of arguments, as different event handlers won't necessarily have the same signature. Moreover, \", _jsx(_components.code, {\n        children: \"IInputListener::keyDown\"\n      }), \"(and every other potential handler) needs to receive a \", _jsx(_components.code, {\n        children: \"this\"\n      }), \" pointer along the remaining arguments.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This is where \", _jsx(_components.a, {\n        href: \"http://www.cplusplus.com/articles/EhvU7k9E/\",\n        children: \"variadic templates\"\n      }), \" come into play. Basically, they're templates that can take an arbitrary number of parameters of any type.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Interestingly enough, \", _jsx(_components.code, {\n        children: \"std::bind()\"\n      }), \" also takes an arbitrary number of parameters. That means we can create an \", _jsx(_components.code, {\n        children: \"std::function\u003e\"\n      }), \" object that has everything we need: the event handler function pointer, \", _jsx(_components.code, {\n        children: \"this\"\n      }), \" and the remaining arguments.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Take a look at the code.\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"template \u0026lt;class Function, class... Arguments\u0026gt;\\ninline void notify(Function\u0026amp;\u0026amp; f, Arguments\u0026amp;\u0026amp;... args)\\n{\\n    m_notifying = true;\\n    for (Type listener : m_listeners)\\n    {\\n        auto callback = std::bind(f, listener, args...);\\n        callback(listener);\\n    }\\n    m_notifying = false;\\n\\n    for (Type listener : m_pendingRemoval)\\n    {\\n        m_listeners.erase(listener);\\n    }\\n\\n    m_pendingRemoval.clear();\\n\\n    for (Type listener : m_pendingAddition)\\n    {\\n        m_listeners.insert(listener);\\n    }\\n\\n    m_pendingAddition.clear();\\n}\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Note how we process the pending requests to add or remove listeners after we finish sending the events, that's when it's safe.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now we can do exactly what we wanted!\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"ListenerSet\u0026lt;IInputListener*\u0026gt; listeners;\\n\\nlisteners.addListener(new PlayerInputListener());\\nlisteners.addListener(new UserInterfaceInputListener());\\n\\nm_listenerSet.notify(\u0026amp;IInputListener::keyDown, keyCode);\\nm_listenerSet.notify(\u0026amp;IInputListener::keyUp, keyCode);\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Templates are instantiated at compile time, which means the compiler will complain if we're doing something dodgy such as trying to bind the wrong thing. Compile time checks are good.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Managing a set of listeners and sending events is now a lot easier, safer and readable. Last but not least, it's significantly less error prone.\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"Hooray!!!\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Full source\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For those interested, I've made the code available as a GitHub Gist.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://gist.github.com/dsaltares/11212605\",\n        children: \"ListenerSet implementation\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","scope":{}},"series":null},"__N_SSG":true},"page":"/[slug]","query":{"slug":"listenerset-using-variadic-templates"},"buildId":"tqJOQD0pEW5bmwVi0mnQc","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>