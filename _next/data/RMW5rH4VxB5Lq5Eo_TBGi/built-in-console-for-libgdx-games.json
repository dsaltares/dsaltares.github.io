{"pageProps":{"metadata":{"path":"content/post/2016-02-20-built-in-console-for-libgdx-games.mdx","title":"Built-in console for Libgdx games","date":"2016-02-20T16:32:07.000Z","categories":["Games development"],"series":null,"description":null,"slug":"built-in-console-for-libgdx-games","readingTime":"3 min read","draft":false,"disableComments":false,"keywords":[]},"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    a: \"a\",\n    code: \"code\",\n    div: \"div\",\n    pre: \"pre\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"A lot of games come with a built-in console that lets you enter commands, which is especially useful during development. Most times, it gets disabled before shipping although, occasionally, devs let you bring it up and enter cheat codes. CryEngine comes with a built-in console.\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/others/console1.jpg\",\n      alt: \"console1.jpg\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"When you\\\"re testing a new feature you just wrote, it can be incredibly useful to pause, reset the scene, teleport your character, become invincible, switch to a different level or even adjust some parameters in the AI. Some engines use a scripting language that can hot-reload new or modified scripts, but that may not always be feasible. Having a built-in console to enter these commands surely is pretty darn handy! It would be reasonably easy to write a custom console with Libgdx, you just need to leverage Scene2D and have some logic to support arbitrary commands and let the game code handle them. But why do that when you have \", _jsx(_components.a, {\n        href: \"https://github.com/StrongJoshua/libgdx-inGameConsole\",\n        children: _jsx(_components.code, {\n          children: \"libgdx-inGameConsole\"\n        })\n      }), \"? No reason at all! It's incredibly simple to set it up. First, add the following dependency to your \", _jsx(_components.code, {\n        children: \"build.gradle\"\n      }), \" file and refresh your project's dependencies. compile \\\"com.strongjoshua:libgdx-inGameConsole:0.3.2\\\" You can instantiate the \", _jsx(_components.code, {\n        children: \"Console\"\n      }), \" inside your \", _jsx(_components.code, {\n        children: \"create()\"\n      }), \" method. Use the \", _jsx(_components.code, {\n        children: \"setSizePercent()\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"setPositionPercent()\"\n      }), \" methods to configure where your console will show up and how much of the screen it\\\"ll take. Finally, you can also override the key to toggle the console.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"private Console console;\\n\\n@Override\\npublic void create() {\\n    ...\\n\\n    console = new Console();\\n    console.setSizePercent(100, 33);\\n    console.setPositionPercent(0, 67);\\n    console.setKeyID(Keys.Z);\\n}\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Remember to call \", _jsx(_components.code, {\n        children: \"draw()\"\n      }), \" inside your \", _jsx(_components.code, {\n        children: \"render()\"\n      }), \" method.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"console.draw();\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Wonderful, we now have a working in-game console capable of doing absolutely nothing. We need to add our command processing logic. Let's specialize the \", _jsx(_components.code, {\n        children: \"CommandExecutor\"\n      }), \" class and add some methods to load a level and spawn baddies.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"public class GameCommandExecutor extends Command {\\n    private Console console;\\n\\n    public GameCommandExecutor(Console console) {\\n        this.console = console;\\n    }\\n\\n    public void loadLevel(String levelName) {\\n        console.log(&quot;loading level &quot; + levelName, Console.LogLevel.SUCCESS);\\n    }\\n\\n    public void spawnEnemy(String type, float x, float y, float z) {\\n        console.log(&quot;spawning enemy &quot; + type, Console.LogLevel.SUCCESS);\\n    }\\n\\n    public void clear() {\\n        console.clear();\\n    }\\n}\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"At some point, we need to register the executor with the console.\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"console.setCommandExecutor(new GameCommandExecutor(console));\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Done, that's it!\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/others/libgdx-console.png\",\n      alt: \"libgdx-console.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The console uses the Libgdx reflection module to figure out which commands your \", _jsx(_components.code, {\n        children: \"CommandExecutor\"\n      }), \" supports, which means it's fully compatible with the WebGL backend. It's also possible to configure the look and feel of the console if you provide a \", _jsx(_components.code, {\n        children: \"Skin\"\n      }), \" to its constructor. To know more, check its comprehensive \", _jsx(_components.a, {\n        href: \"http://strongjoshua.com/javadocs/in-game_console/\",\n        children: \"documentation\"\n      }), \".\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","scope":{}},"series":null},"__N_SSG":true}