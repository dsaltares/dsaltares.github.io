{"pageProps":{"metadata":{"path":"content/post/2011-02-09-colisiones-ii-diseno-general-de-stc.mdx","title":"Colisiones II: Diseño general de STC","date":"2011-02-09T08:00:45.000Z","categories":["Games development"],"series":null,"description":null,"slug":"colisiones-ii-diseno-general-de-stc","readingTime":"3 min read","draft":false,"disableComments":false,"keywords":[]},"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    img: \"img\",\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    a: \"a\",\n    em: \"em\",\n    strong: \"strong\",\n    h3: \"h3\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.img, {\n      src: \"/img/wp/colisiones-2.png\",\n      alt: \"colisiones-2.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Entregas:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/proyectos/pfc/sion-tower/colisiones-i-introduccion-requisitos-y-alternativas/\",\n          children: \"Colisiones I: Introducción, requisitos y alternativas\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.em, {\n          children: \"Colisiones II: Diseño general de STC\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/proyectos/pfc/sion-tower/colisiones-iii-shape-y-collision-dispatching/\",\n          children: \"Colisiones III: La clase Shape y Collision Dispatching\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/proyectos/pfc/sion-tower/colisiones-iv-tests-de-colision/\",\n          children: \"Colisiones IV: Tests de colisión\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"En la primera entrega de la serie de artículos sobre el \", _jsx(_components.strong, {\n        children: \"sistema de detección de colisiones de Sion Tower (STC)\"\n      }), \" comenté los requisitos que debía cumplir y las alternativas que valoré antes de decidirme a implementarlo por cuenta propia. En esta ocasión me dispongo a hacer \", _jsx(_components.strong, {\n        children: \"un repaso por el diseño de esta pequeña biblioteca\"\n      }), \". Tras el diagrama de clases voy a tratar los componentes de forma breve pero individualizada. En posteriores entregas del artículo tendremos espacio suficiente para conocer en profundidad cada clase y algunos puntos relevantes de su implementación.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Diagrama de clases de diseño\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"El sistema de colisiones de Sion Tower es bastante sencillo y únicamente cuenta con las clases que se muestran a continuación.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Este primer diagrama sólo muestra las clases y sus relaciones:\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/collisions-simplified.png\",\n      alt: \"collisions-simplified.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"En este segundo diagrama podemos ver los métodos que componen la interfaz de cada clase, haz click sobre la imagen para verlo ampliado.\"\n    }), \"\\n\", _jsx(_components.a, {\n      href: \"/img/wp/collisions-interface.png\",\n      children: _jsx(_components.img, {\n        src: \"/img/wp/collisions-interface.png\",\n        alt: \"collisions-interface.png\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Componentes\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"La siguiente lista repasa de forma superficial las responsabilidades de cada clase dentro de Sion Tower Collisions.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Shape\"\n        }), \": clase abstracta que modela formas básicas colisionables. Es la encargada del \", _jsx(_components.em, {\n          children: \"\\\"collision dispatching\\\"\"\n        }), \". Mediante el método estático \", _jsx(_components.em, {\n          children: \"Shape::getCollision\"\n        }), \" podemos saber si dos formas concretas colisionan sin necesidad de conocer su clase concreta. El sistema detecta los tipos en tiempo de ejecución (\", _jsx(_components.a, {\n          href: \"http://en.wikipedia.org/wiki/Run-time_type_information\",\n          children: \"RTTI\"\n        }), \") y elije el test de colisión apropiado de manera eficiente.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Plane\"\n        }), \": forma especializada para modelar un plano representado por un punto y un vector normal. Dentro del juego lo utilizaremos para modelar las colisiones del suelo.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Sphere\"\n        }), \": forma especializada para modelar una esfera a partir de un punto (centro) y un radio. Nos será de extrema utilidad para modelar el volumen colisionable de los proyectiles mágicos.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"AABB\"\n        }), \": forma especializada para modelar una caja de colisión alineada con los ejes (\", _jsx(_components.a, {\n          href: \"http://en.wikipedia.org/wiki/Bounding_volume#Common_types_of_bounding_volume\",\n          children: \"Axis Aligned Bounding Box\"\n        }), \"), se representa mediante su punto mínimo y máximo. Será útil para modelar elementos que no roten ya que los AABB pierden mucha precisión en estas situaciones.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Body\"\n        }), \": cuerpo colisionable formado por varios objetos \", _jsx(_components.em, {\n          children: \"Shape\"\n        }), \" y una transformación (translación con respecto al origen, escala y rotación). Representará la parte física de los objetos del juego dentro de la escena (\", _jsx(_components.em, {\n          children: \"world space\"\n        }), \"). Proporciona el método estático \", _jsx(_components.em, {\n          children: \"Body::getCollision\"\n        }), \" para conocer si dos cuerpos se interseccionan. Los cuerpos tienen un tipo para poder distinguir entre clases de cuerpos de cara al filtrado de colisiones.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"CollisionManager\"\n        }), \": registra todos los cuerpos de la escena y permite detectar colisiones entre ellos. Habilita el registro de callbacks para ser informados de colisiones entre dos tipos concretos de cuerpos.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"GameObject\"\n        }), \": encapsula el aspecto colisionable (\", _jsx(_components.em, {\n          children: \"Body\"\n        }), \") junto con el visual (\", _jsx(_components.em, {\n          children: \"Ogre::Entity\"\n        }), \" – \", _jsx(_components.em, {\n          children: \"Ogre::SceneNode\"\n        }), \") de los elementos de juego. Los elementos que no tengan un comportamiento definido serán instancias de esta clase. Aquellos que deseen un comportamiento concreto deberán heredar de \", _jsx(_components.em, {\n          children: \"GameObject\"\n        }), \".\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Básicamente esto es lo que proporciona STC, \", _jsx(_components.strong, {\n        children: \"no es mucho pero es fácil de extender\"\n      }), \" y es independiente del resto de componentes de un videojuego.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","scope":{}},"series":null},"__N_SSG":true}