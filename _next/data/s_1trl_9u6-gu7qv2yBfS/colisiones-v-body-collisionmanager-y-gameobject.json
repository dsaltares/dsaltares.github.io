{"pageProps":{"metadata":{"path":"content/post/2011-02-17-colisiones-v-body-collisionmanager-y-gameobject.mdx","title":"Colisiones V: Body, CollisionManager y GameObject","date":"2011-02-17T22:19:42.000Z","categories":["Games development"],"series":null,"description":null,"slug":"colisiones-v-body-collisionmanager-y-gameobject","readingTime":"4 min read","draft":false,"disableComments":false,"keywords":[],"banner":null},"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    img: \"img\",\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    a: \"a\",\n    em: \"em\",\n    strong: \"strong\",\n    h3: \"h3\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.img, {\n      src: \"/img/wp/colisiones-5.png\",\n      alt: \"colisiones-5.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Entregas\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/proyectos/pfc/sion-tower/colisiones-i-introduccion-requisitos-y-alternativas/\",\n          children: \"Colisiones I: Introducción, requisitos y alternativas\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/proyectos/pfc/sion-tower/colisiones-ii-diseno-general-de-stc/\",\n          children: \"Colisiones II: Diseño general de STC\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/proyectos/pfc/sion-tower/colisiones-iii-shape-y-collision-dispatching/\",\n          children: \"Colisiones III: Shape y Collision Dispatching\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/proyectos/pfc/sion-tower/colisiones-iv-tests-de-colision/\",\n          children: \"Colisiones IV: Tests de colisión\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.em, {\n          children: \"Colisiones V: Body, CollisionManager y GameObject\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Esta es la \", _jsx(_components.strong, {\n        children: \"quinta y última entrega\"\n      }), \" de la serie de artículos sobre el sistema de detección de colisiones de Sion Tower (STC). \", _jsx(_components.strong, {\n        children: \"Trataremos las últimas clases\"\n      }), \" que nos queda por ver: \", _jsx(_components.em, {\n        children: \"Body\"\n      }), \", \", _jsx(_components.em, {\n        children: \"CollisionManager\"\n      }), \" y \", _jsx(_components.em, {\n        children: \"GameObject\"\n      }), \". Finalmente hablaré de las correcciones y mejoras que implementaré lo antes posible de cara a una futura versión.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"La clase Body\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Un \", _jsx(_components.em, {\n        children: \"Body\"\n      }), \" representa la \", _jsx(_components.strong, {\n        children: \"parte colisionable de un objeto\"\n      }), \" y está formado por un vector de formas (\", _jsx(_components.em, {\n        children: \"Shape\"\n      }), \") y una transformación (traslación con respecto al origen, escala y rotación). Los cuerpos tienen un tipo (entero) que permite agruparlos y filtrarlos en la detección de colisiones. Para manejar las colisiones entre dos cuerpos, debemos cruzar las formas de ambos en coordenadas del mundo, en ningún caso locales al objeto. Aplicar la transformación de cada cuerpo a cada forma en todas las iteraciones del bucle de juego es demasiado costoso. Por ello, he decidido almacenar un segundo vector de formas en coordenadas del mundo, en el eterno dilema de la eficiencia tempo/memoria ha ganado el tiempo en este caso.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/body1.png\",\n      alt: \"body1.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"¿Por qué no tener un sólo vector de formas en coordenadas del mundo? En la carga de niveles utilizaré una fábrica que guardará instancias de objetos como muros, mobiliario y otros elementos. Necesitaré copiarlos y por eso es más cómodo emplear coordenadas locales y luego transformarlas una sola vez.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"La clase CollisionManager\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"El gestor de colisiones sigue el patrón de diseño \", _jsx(_components.a, {\n        href: \"http://es.wikipedia.org/wiki/Singleton\",\n        children: \"Singleton\"\n      }), \" y \", _jsx(_components.strong, {\n        children: \"lleva el registro de todos los cuerpos colisionables\"\n      }), \" de la escena. Es posible añadir o eliminar cuerpos según nos convenga. Una vez en cada iteración del bucle de juego es recomendable llamar al método \", _jsx(_components.em, {\n        children: \"checkCollisions\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Sólo se comprobarán colisiones entre cuerpos para cuyo tipo exista un callback. Los callbacks son objetos función de Boost que reciben dos punteros a \", _jsx(_components.em, {\n        children: \"Body\"\n      }), \" y no devuelven nada. Utilizando \", _jsx(_components.em, {\n        children: \"boost:bind\"\n      }), \" podemos crear un objeto \", _jsx(_components.em, {\n        children: \"boost:function\"\n      }), \" y añadir el callback para dos cuerpos de un tipo determinado. Por ejemplo, podemos hacer que el método \", _jsx(_components.em, {\n        children: \"callbackSpellEnemy\"\n      }), \" sea llamado cuando colisionen cuerpos de los supuestos tipos \", _jsx(_components.em, {\n        children: \"Spell\"\n      }), \" (cuyo número podría ser el 4) y \", _jsx(_components.em, {\n        children: \"Enemy\"\n      }), \" (cuyo número podría ser el 8).\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"En el método \", _jsx(_components.em, {\n        children: \"checkCollisions\"\n      }), \" no sólo se filtran los cuerpos para los que existe un callback definido sino que no se comprueban aquellos que están a una distancia prudencial. Soy consciente de que para cantidades ingentes de elementos este \", _jsx(_components.strong, {\n        children: \"particionado\"\n      }), \" no es suficiente aunque por el momento funciona correctamente.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/collisionmanager.png\",\n      alt: \"collisionmanager-250x300.png\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"La clase GameObject\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"La última clase que nos quedaba por repasar era \", _jsx(_components.em, {\n        children: \"GameObject\"\n      }), \", como ya he mencionado se encarga de \", _jsxs(_components.strong, {\n        children: [\"encapsular la parte visual (\", _jsx(_components.em, {\n          children: \"SceneNode\"\n        }), \" + \", _jsx(_components.em, {\n          children: \"Entity\"\n        }), \") y colisionable (\", _jsx(_components.em, {\n          children: \"Body\"\n        }), \") de los elementos\"]\n      }), \" de juego. Proporciona métodos para actualizar posición, escala y rotación pero si lo deseamos se nos permite acceder al nodo o al cuerpo que contiene. Si hacemos modificaciones sobre el nodo o el cuerpo tendremos que sincronizar la otra parte empleando los métodos \", _jsx(_components.em, {\n        children: \"synchronizeBody\"\n      }), \" o \", _jsx(_components.em, {\n        children: \"synchronizeNode\"\n      }), \" según corresponda.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Cuenta con un método virtual update que no hace nada y está diseñado para ser sobrecargado. No es una clase abstracta de la que no puedan existir instancias aunque lo usual es heredar de ella y aportar un comportamiento concreto.\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/gameobject.png\",\n      alt: \"gameobject-300x106.png\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Próximas versiones\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"El sistema de detección de colisiones de Sion Tower presenta un amplio margen de mejora. Tengo anotada una buena lista y ya he conseguido implementar algunas de ellas. En la futura versión 0.2 de la mini biblioteca encontraréis la forma \", _jsx(_components.em, {\n        children: \"OrientedBox\"\n      }), \" (OBB), nuevos tests de colisión, una API más extensible y muchas correcciones de bugs.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","scope":{}},"series":null},"__N_SSG":true}