{"pageProps":{"metadata":{"path":"content/post/2010-10-01-backup-a-traves-de-la-red-con-tar-y-ssh.mdx","title":"Backup a través de la red con tar y ssh","date":"2010-10-01T19:38:16.000Z","categories":["Computing"],"series":null,"description":null,"slug":"backup-a-traves-de-la-red-con-tar-y-ssh","readingTime":"3 min read","draft":false,"disableComments":false,"keywords":[],"banner":null},"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    img: \"img\",\n    p: \"p\",\n    strong: \"strong\",\n    h3: \"h3\",\n    div: \"div\",\n    pre: \"pre\",\n    code: \"code\",\n    em: \"em\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.img, {\n      src: \"/img/wp/tar-ssh.webp\",\n      alt: \"tar-ssh.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"La administración de sistemas no es una de mis pasiones pero en mi trabajo actual tengo que ejercer dicha actividad combinada con el desarrollo web. Hace unas semanas \", _jsx(_components.strong, {\n        children: \"tuvimos que actualizar una aplicación web\"\n      }), \" que manejaba un volumen bastante importante de datos. A pesar de que se hacían copias incrementales diarias utilizando rsync \", _jsx(_components.strong, {\n        children: \"estimamos oportuno hacer una copia completa\"\n      }), \" y colocarla en una máquina distinta por si la ley de Murphy decidía darnos una lección. El texto que sigue es un truco para hacer \", _jsx(_components.strong, {\n        children: \"una copia gigantesca y mandarla mediante ssh\"\n      }), \" a otra máquina \", _jsx(_components.strong, {\n        children: \"sin perder demasiado el tiempo\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"La respuesta rápida (y cutre)\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Comprimir \", _jsx(_components.strong, {\n        children: \"200GB\"\n      }), \" con tar y transferirlos vía ssh es extremadamente lento aunque las máquinas estén en la misma subred. Este sería \", _jsx(_components.strong, {\n        children: \"el enfoque inicial\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"# Comprimimos\\ntar cvzf directorio directorio.tar.gz\\n\\n# Enviamos\\nscp directorio.tar.gz usuario@host:directorio_destino\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"La solución\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Decidimos que \", _jsx(_components.strong, {\n        children: \"el tiempo era oro\"\n      }), \", máxime cuando el backup y la actualización implicaban cortar el servicio a todos los usuarios. Lo ideal sería ir enviando datos a medida que éstos se van comprimiendo. Un poco de búsqueda en Google y retoque de parámetros para ajustarlo a nuestras necesidades bastaron para ahorrar prácticamente la mitad de tiempo. A continuación \", _jsx(_components.strong, {\n        children: \"el script que encierra la magia\"\n      }), \" (obviando datos concretos):\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"#!/bin/sh\\n\\n# Fecha de la copia\\nFECHA=$(date +&quot;%F-%H-%M-%S&quot;)\\n\\n# Directorio a copiar\\nDIR_BACKUP=/home/david\\n\\n# Máquina remota\\nHOST=backups.saltares.com\\n\\n# Usuario de la máquina remota\\nUSER=siondream\\n\\n# Directorio destino\\nHOST_DIR=/home/siondream/backups\\n\\n# Hacemos el backup\\ntar cvzf - $DIR_BACKUP | ssh $USER@$HOST &quot;cat &gt; ${HOST_DIR}/${DIR_BACKUP}-${FECHA}.tar.gz&quot;\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Con el clásico \", _jsx(_components.em, {\n        children: \"tar cvzf\"\n      }), \" tenemos una compresión común de \", _jsx(_components.em, {\n        children: \"$DIR_BACKUP\"\n      }), \". No obstante, el guión \", _jsx(_components.em, {\n        children: \"–\"\n      }), \" sirve para desviar el flujo a la salida estándar la cual convertimos en la entrada estándar del siguiente comando mediante la tubería \", _jsx(_components.em, {\n        children: \"|\"\n      }), \". El chorro de bytes se envía mediante \", _jsx(_components.em, {\n        children: \"ssh\"\n      }), \" (al equipo \", _jsx(_components.em, {\n        children: \"$HOST\"\n      }), \" con nuestro usuario \", _jsx(_components.em, {\n        children: \"$USER\"\n      }), \") y se vuelca en el fichero \", _jsx(_components.em, {\n        children: \"$DIR_BACKUP-$FECHA.tar.gz\"\n      }), \" utilizando \", _jsx(_components.em, {\n        children: \"cat\"\n      }), \". Puede parecer algo confuso pero \", _jsx(_components.strong, {\n        children: \"si lo piensas es maravilloso\"\n      }), \" y tiene todo el sentido del mundo.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Lo mismo casi en la mitad de tiempo\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Si tienes que hacer grandes copias y enviarlas por la red, \", _jsx(_components.strong, {\n        children: \"este pequeño truco es tu amigo\"\n      }), \". Tras completar el proceso de actualización con éxito hice algunas pruebas para calcular la mejora que proporciona esta técnica. Obtuve \", _jsx(_components.strong, {\n        children: \"resultados impresionantes\"\n      }), \": enviar los datos mientras éstos se comprimen lleva \", _jsx(_components.strong, {\n        children: \"casi la mitad de tiempo\"\n      }), \" que hacerlo en etapas separadas.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","scope":{}},"series":null},"__N_SSG":true}