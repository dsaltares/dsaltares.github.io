{"pageProps":{"metadata":{"path":"content/post/2015-12-13-thoughts-on-unit-testing-for-ashley-and-games-in-general.mdx","title":"Thoughts on unit testing for Ashley and games in general","date":"2015-12-13T15:21:50.000Z","categories":["Games development"],"series":null,"description":null,"slug":"thoughts-on-unit-testing-for-ashley-and-games-in-general","readingTime":"5 min read","draft":false,"disableComments":false,"keywords":[]},"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    h3: \"h3\",\n    ul: \"ul\",\n    li: \"li\",\n    img: \"img\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"Shortly after we moved \", _jsx(_components.a, {\n        href: \"https://github.com/libgdx/ashley\",\n        children: \"Ashley\"\n      }), \" into the \", _jsx(_components.a, {\n        href: \"https://github.com/libgdx\",\n        children: \"Libgdx\"\n      }), \" family, we started writing \", _jsx(_components.a, {\n        href: \"https://github.com/libgdx/ashley/tree/master/ashley/tests/com/badlogic/ashley\",\n        children: \"unit tests\"\n      }), \" for every single component in the framework using \", _jsx(_components.a, {\n        href: \"http://junit.org/\",\n        children: \"jUnit\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Unit testing goodness\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"That was over a year and a half ago and it has proven to be a huge win for many reasons.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Issue reporters can (and should) include a \", _jsx(_components.a, {\n          href: \"https://github.com/libgdx/ashley/issues/173\",\n          children: \"test that breaks\"\n        }), \" as a way of explaining the problem. We can then easily include it into the suite, fix it and prevent future regressions.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Pull requests \", _jsx(_components.a, {\n          href: \"https://github.com/libgdx/ashley/pull/187\",\n          children: \"trigger a build\"\n        }), \" in Jenkins that compiles the code and runs all the unit tests. Code reviews should check for design, good practices as well as correctness. However, as long as the tests have good coverage, we can be pretty sure the change won't break existing code.\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Since, it is mandatory to include extensive unit tests with each new feature, we can increase quality from the get go.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Refactoring becomes a lot easier. We lose fear of cleaning up ugly parts of the codebase because we have unit tests to make sure the behaviour remains the same. This became evident with the recent \", _jsx(_components.a, {\n          href: \"https://github.com/libgdx/ashley/commit/261342f74dc7c1b955e7605aadeb9bfcbc112128\",\n          children: \"Engine internal refactor\"\n        }), \".\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The morale is basically as follows.\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/unit-test-all-the-things.png\",\n      alt: \"unit-test-all-the-things.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Our \", _jsx(_components.a, {\n        href: \"https://github.com/libgdx/ashley/issues?q=is%3Aissue+is%3Aclosed\",\n        children: \"issue tracker\"\n      }), \" proves that we're far from perfect, which makes me thing about where we'd be if it weren't for unit tests. Ashley inherently has lots of tricky bits of logic and potential edge cases. Making sure we don't break anything without automated tests would almost impossible.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"That is why, every time we break something, we add a unit test with the fix and make sure it never ever happens again.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Lack of unit testing in the games industry\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"When I left the games industry as a full time occupation something struck me. There's an incredibly poor unit testing culture in games compared to other industries. Sure, other industries are also affected by this disease but I've felt a lack of attitude in the games world to change the situation.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This is really, really bad.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As you surely know, games are complex pieces of code. Many systems with non-trivial logic interact in a real-time simulation all at once. Games development is hard! Actually, it's more than that! It's brain melting!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"When a deadline approaches and the bug count shoots over the roof, we put in hacky fixes and hope for the best. Then our WTFs per line increase and no one ever dares to fix it because they're scared of breaking everything. So we keep pushing forward until the game's unavoidably collapses on us.\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/wtf.png\",\n      alt: \"wtf.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Some people may say that decoupling and correctly abstracting code for it to be more easily testable may add an overhead games cannot afford. I would tell them that's a huge empty fallacy until proven otherwise and quite possibly fall within \", _jsx(_components.a, {\n        href: \"http://c2.com/cgi/wiki?PrematureOptimization\",\n        children: \"premature optimisation\"\n      }), \". These claims need to be backed by profiling data and I seriously doubt these practices will become someone's main bottleneck.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Clean and performant code is possible.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"We can do better than this\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Admittedly, games are very hard to test. How can you unit test a shader or a behaviour script? Many things depend on graphics or user input and we cannot automate them!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here is a few things you can do.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Unit test foundational classes like \", _jsx(_components.a, {\n          href: \"https://github.com/libgdx/libgdx/blob/master/gdx/test/com/badlogic/gdx/math/IntersectorTest.java\",\n          children: \"geometry intersectors\"\n        }), \" or \", _jsx(_components.a, {\n          href: \"https://github.com/libgdx/libgdx/blob/master/gdx/test/com/badlogic/gdx/utils/PooledLinkedListTest.java\",\n          children: \"containers\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Write tests for game specific logic that does not depend on graphics nor user input.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Make sure you have a \", _jsx(_components.a, {\n          href: \"https://github.com/libgdx/libgdx/tree/master/backends/gdx-backend-headless\",\n          children: \"headless backend\"\n        }), \" for your engine, that way you can run it without requiring a graphic environment.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Use \", _jsx(_components.a, {\n          href: \"https://en.wikipedia.org/wiki/Dependency_injection\",\n          children: \"dependency injection\"\n        }), \", so you can mock those dependencies in a unit test. Don't have your \", _jsx(_components.code, {\n          children: \"Player\"\n        }), \" internally use a \", _jsx(_components.code, {\n          children: \"PlayerController\"\n        }), \", give it a reference to \", _jsx(_components.code, {\n          children: \"ControllerInterface\"\n        }), \" in the constructor. This way you can test Player behaves well without relying on an actual keyboard.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Higher level systems can be really tricky to test, especially if they're strongly tied to user input. In those situations, you can write an \", _jsx(_components.a, {\n        href: \"https://en.wikipedia.org/wiki/Integration_testing\",\n        children: \"integration test\"\n      }), \" that fakes user input and validate the output.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Designing your game to be unit testable is hard and may take longer but think about it as an investment. In the long run, you will face less roadblocks and will be able to iterate faster. No need to do this for a game jam prototype although I would certainly recommend it for a more serious project.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It's undeniable that writing unit tests is time consuming but I strongly believe the games industry completely underestimate their usefulness.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Finally, let me recommend \", _jsx(_components.a, {\n        href: \"/computing/book-review-clean-code/\",\n        children: \"Clean Code\"\n      }), \" again.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","scope":{}},"series":null},"__N_SSG":true}