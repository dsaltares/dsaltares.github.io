{"pageProps":{"metadata":{"path":"content/post/2011-04-05-sistema-de-busqueda-de-caminos.mdx","title":"Sistema de búsqueda de caminos","date":"2011-04-05T20:23:30.000Z","categories":["Games development"],"series":null,"description":null,"slug":"sistema-de-busqueda-de-caminos","readingTime":"4 min read","draft":false,"disableComments":false,"keywords":[],"banner":null},"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    img: \"img\",\n    p: \"p\",\n    a: \"a\",\n    strong: \"strong\",\n    h3: \"h3\",\n    ul: \"ul\",\n    li: \"li\",\n    em: \"em\",\n    ol: \"ol\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.img, {\n      src: \"/img/wp/titulo-navmesh.png\",\n      alt: \"titulo-navmesh.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Hace unos días publicaba un \", _jsx(_components.a, {\n        href: \"/proyectos/pfc/sion-tower/sion-tower-navigation-mesh-y-a/\",\n        title: \"Sion Tower, navigation mesh y A*\",\n        children: \"vídeo\"\n      }), \" mostrando el \", _jsx(_components.strong, {\n        children: \"sistema de búsqueda de caminos empleando mallas de navegación\"\n      }), \" y el algoritmo A estrella para Sion Tower. Pudisteis ver que el personaje recorría el camino de forma brusca, actualmente el problema se ha solucionado gracias a la \", _jsx(_components.strong, {\n        children: \"inclusión de splines en una colaboración\"\n      }), \" del compañero \", _jsx(_components.a, {\n        href: \"http://ragingbit.com/blog/\",\n        children: \"Javier Santacruz\"\n      }), \" (\", _jsx(_components.a, {\n        href: \"http://twitter.com/#!/arld101\",\n        children: \"@arld101\"\n      }), \"). ¡La primera colaboración en forma de código! En este artículo nos centraremos en ilustrar a grandes rasgos \", _jsx(_components.strong, {\n        children: \"como funciona la búsqueda\"\n      }), \" de caminos internamente.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Conceptos generales\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"El problema inicial era la \", _jsx(_components.strong, {\n        children: \"necesidad de que los enemigos pudiesen moverse\"\n      }), \" por el escenario hacia un objetivo evitando los obstáculos estáticos. El ejemplo más común sería el de perseguir al protagonista para atacarle. Para ello es necesario definir las zonas transitables de alguna manera y la respuesta es emplear una malla de navegación.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"En \", _jsx(_components.a, {\n        href: \"http://www.blender.org/\",\n        children: \"Blender\"\n      }), \" se crea una \", _jsx(_components.strong, {\n        children: \"malla compuesta de triángulos interconectados\"\n      }), \" tal y como se ilustra en la imagen que ya he mostrado en alguna ocasión. El sistema de carga de niveles procesa la malla y genera un grafo de forma interna. Realizar búsqueda de caminos dentro del grafo es un problema conocido y relativamente sencillo de resolver como veremos más adelante. Además el sistema soporta celdas con inclinación (como en las escaleras) aunque al algoritmo esto le es indiferente.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/blender-navmesh.jpg\",\n      alt: \"blender-navmesh.jpg\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Clases implicadas\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"El sistema de búsqueda de caminos de Sion Tower está compuesto por las clases del siguiente diagrama:\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/clases-navmesh.png\",\n      alt: \"clases-navmesh.png\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.em, {\n          children: \"Cell\"\n        }), \": representa una celda triangular de la malla.*   \", _jsx(_components.em, {\n          children: \"NavigationMesh\"\n        }), \": malla de navegación formada por un grafo de \", _jsx(_components.em, {\n          children: \"Cells\"\n        }), \". Permite localizar elementos en celdas de la malla, conocer la altura a la que debe colocarse un personaje para pegarlo al suelo, realizar consultas de línea de visión y búsqueda de caminos.*   \", _jsx(_components.em, {\n          children: \"CellNode\"\n        }), \": nodo de la búsqueda de caminos. Tiene asociado una \", _jsx(_components.em, {\n          children: \"Cell\"\n        }), \", y los costes de la heurística.*   \", _jsx(_components.em, {\n          children: \"Level\"\n        }), \": ya hablamos de ella en \", _jsx(_components.a, {\n          href: \"/proyectos/pfc/sion-tower/creacion-de-escenarios-en-formato-dotscene-con-blender/\",\n          title: \"Creación de escenarios en formato DotScene con Blender\",\n          children: \"otra ocasión\"\n        }), \". Se encarga de cargar y almacenar la información de los niveles desde ficheros en formato XML. Entre la información del nivel, carga un \", _jsx(_components.em, {\n          children: \"NavigationMesh\"\n        }), \".\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Algoritmo A*\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"El \", _jsx(_components.strong, {\n        children: _jsx(_components.a, {\n          href: \"http://en.wikipedia.org/wiki/A*_search_algorithm\",\n          children: \"algoritmo A*\"\n        })\n      }), \" es de sobra conocido por muchos y puede obtenerse mucha información sobre el mismo en decenas de fuentes. En la búsqueda de Sion Tower le indicamos una posición de comienzo y una de destino al método \", _jsx(_components.em, {\n        children: \"buildPath\"\n      }), \" de \", _jsx(_components.em, {\n        children: \"NavigationMesh\"\n      }), \" y se nos devuelve una lista de puntos por los que hay que pasar. De forma esquematizada \", _jsx(_components.strong, {\n        children: \"se hace lo siguiente\"\n      }), \":\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Encontrar las celdas en las que se encuentran las posiciones de inicio y destino\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Crear un \", _jsx(_components.a, {\n          href: \"http://en.wikipedia.org/wiki/Heap_(data_structure)\",\n          children: \"montículo\"\n        }), \" con un \", _jsx(_components.em, {\n          children: \"CellNode\"\n        }), \" asociado a la primera celda.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Bucle:\", \"\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"Sacar el nodo más prometedor del montículo.\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"Si el nodo corresponde a la celda final, hemos terminado.\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"Introducimos en el montículo los nodos cuyas celdas son vecinas a las del nodo actual.\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"Comenzar de nuevo el paso 3.\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Reconstruir el camino de puntos empleando un spline para evitar cambios bruscos.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Colaboración para suavizar el camino\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"El compañero Francisco Javier Santacruz se interesó en suavizar la ruta resultante de la búsqueda y rápidamente se puso manos a la obra. Tras un par de días de trabajo me envió un parche que apliqué gustosamente por sus \", _jsx(_components.strong, {\n        children: \"impresionantes resultados\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"La forma de suavizar la ruta consiste en generar muchos puntos intermedios \", _jsxs(_components.strong, {\n        children: [\"siguiendo un \", _jsx(_components.a, {\n          href: \"http://es.wikipedia.org/wiki/Spline\",\n          children: \"spline\"\n        })]\n      }), \". Los splines son curvas definidas mediante polinomios: ¡por fin las clases de Métodos Numéricos sirven para algo! En el caso que nos ocupa utilizó el \", _jsx(_components.a, {\n        href: \"http://en.wikipedia.org/wiki/Cubic_Hermite_spline#Catmull.E2.80.93Rom_spline\",\n        children: \"spline de Catmull-Roll\"\n      }), \", un tipo de interpolación cúbica. En la prueba que me mandó se visualizaba la ruta del personaje ya suavizada como una línea en el suelo dibujada con primitivas de Ogre. Simplemente restan por hacer unos pequeños ajustes, \", _jsx(_components.strong, {\n        children: \"¡muchas gracias!\"\n      })]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/siontower-navmesh.jpg\",\n      alt: \"siontower-navmesh.jpg\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Conclusiones\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Implementar el sistema de búsqueda de caminos con una malla de navegación \", _jsx(_components.strong, {\n        children: \"ha sido muy enriquecedor\"\n      }), \" ya que era una materia completamente desconocida por mí hasta el momento. He aprendido mucho sobre las distintas aproximaciones existentes y la forma de aplicarla a un juego tridimensional. Además he obtenido la primera colaboración en términos de código a través de un parche. Los que estéis interesados en los detalles podéis acudir a \", _jsx(_components.a, {\n        href: \"https://forja.rediris.es/plugins/scmsvn/viewcvs.php/siontower/branches/navmesh-javi/?root=cusl5-iberogre\",\n        children: \"la rama correspondiente de la forja\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"¡Seguiré informando!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","scope":{}},"series":null},"__N_SSG":true}