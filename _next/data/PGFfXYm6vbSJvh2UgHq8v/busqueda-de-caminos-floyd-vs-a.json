{"pageProps":{"metadata":{"path":"content/post/2011-06-22-busqueda-de-caminos-floyd-vs-a.mdx","title":"Búsqueda de caminos: Floyd vs A*","date":"2011-06-22T13:46:59.000Z","categories":["Games development"],"series":null,"description":null,"slug":"busqueda-de-caminos-floyd-vs-a","readingTime":"4 min read","draft":false,"disableComments":false,"keywords":[],"banner":null},"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    img: \"img\",\n    p: \"p\",\n    strong: \"strong\",\n    a: \"a\",\n    h3: \"h3\",\n    ol: \"ol\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.img, {\n      src: \"/img/wp/avsfloyd.png\",\n      alt: \"avsfloyd.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Las últimas semanas he estado trabajando en la \", _jsx(_components.strong, {\n        children: \"IA de Sion Tower\"\n      }), \" y por el momento el resultado es satisfactorio. Antes utilizaba el algoritmo \", _jsx(_components.strong, {\n        children: \"A\"\n      }), \" para la búsqueda de caminos de los enemigos, pero me di cuenta de que el rendimiento podía ser mucho mejor si precomputaba las búsquedas con una alternativa como \", _jsx(_components.strong, {\n        children: \"Floyd\"\n      }), \". En este artículo hablo de las dos aproximaciones y comparo los resultados obtenidos.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Aclaración\"\n      }), \": en el texto no voy a entrar en detalles sobre los algoritmos \", _jsx(_components.a, {\n        href: \"http://en.wikipedia.org/wiki/A*_search_algorithm\",\n        children: \"A*\"\n      }), \" ni \", _jsx(_components.a, {\n        href: \"http://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\",\n        children: \"Floyd\"\n      }), \". Si no los conoces deberías consultar los sendos artículos de Wikipedia o tu libro de algoritmia preferido.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Aproximación 1: algoritmo A*\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Como ya he dicho alguna vez, utilizo una malla de navegación diseñada con Blender para definir el área transitable por los enemigos. \", _jsx(_components.strong, {\n        children: \"Cada vez que algún monstruo desea saber el camino\"\n      }), \" hacia el personaje se realizaban los siguientes pasos:\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Ejecutar A* desde la celda del enemigo hasta la del personaje.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Recuperar camino devuelto por A*.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Simplificar el camino eliminando celdas intermedias para evitar zig-zag.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Suavizado del camino mediante spline cúbico.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Los pasos 1 y 3 resultaban especialmente costosos en términos de tiempo mientras que los pasos 2 y 4 eran muy rápidos. Traté de minimizar la necesidad de recalcular rutas hacia el protagonista pero cuando el jugador se desplaza demasiado, resulta inevitable.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Aproximación 2: algoritmo de Floyd\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Al ejecutar A* cada vez que un enemigo deseaba rehacer su ruta estábamos incurriendo en muchos cálculos redundantes. \", _jsx(_components.strong, {\n        children: \"¿Por qué no precomputar los caminos mínimos?\"\n      }), \" Eso es precisamente lo que hace el algoritmo de Floyd, calcula los costes y el camino para viajar entre todos los pares de nodos x e y de un grafo. El resultado lo almacena en una matriz de costes mínimos (que no nos interesa) y otra de caminos (con la que nos quedaremos).\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Al tener una matriz con los caminos ya calculados, \", _jsx(_components.strong, {\n        children: \"recuperar una ruta es mucho más eficiente\"\n      }), \" en tiempo. Incluso podemos eliminar la simplificación de caminos en cada consulta si también precalculamos todas las simplificaciones posibles. No obstante, se requieren una serie de \", _jsx(_components.strong, {\n        children: \"pasos iniciales\"\n      }), \":\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Construcción de la matriz de costes iniciales a partir de la malla.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Ejecución del algoritmo de Floyd.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Simplificar todos los caminos actualizando la matriz de caminos mínimos.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Cuando un enemigo quiera conocer una ruta, simplemente realizamos los siguientes pasos cuyo tiempo es mínimo:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Recuperar el camino.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Suavizar el camino mediante un spline cúbico.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Comparativa: A* vs Floyd\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Todas las mediciones de tiempo que se muestran a continuación se han realizado sobre el mismo equipo, bajo la misma carga de trabajo y con la misma malla de navegación de 113 celdas.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Coste inicial\"\n      }), \": Utilizar Floyd conlleva una serie de cálculos iniciales que A* no son necesarios. No obstante, podemos ver que son bastante reducidos ya que suponen 2.18ms una sola vez al cargar cada nivel.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Consumo de memoria\"\n      }), \": podría preocuparnos el coste de almacenar la matriz de caminos mínimos. Para 113 celdas tenemos una matriz de 113 _ 113 = 12769 enteros para indexar las celdas que componen los caminos. Esto equivale a 50KB, una cantidad reducida comparada con el tamaño de un modelo 3D animado. Es cierto que la aproximación de Floyd no es tan escalable como A_ por el coste en memoria. Mi escenario de 113 celdas es pequeño, si aumentamos a 1000 celdas, la matriz ocuparía 4MB. Es O(n2) con respecto al número de celdas.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Tiempo para construir un camino\"\n      }), \": aquí es donde Floyd le saca una gran ventaja a A*. Recuperar un camino utilizando A* requiere en término medio 0.5ms mientras que utilizando Floyd necesitamos 0.02ms. La diferencia es muy significativa. Imaginad que tenemos 5 enemigos en pantalla que piden un camino en el mismo frame. Con A* el coste ascendería a 5 * 0.5ms = 2.5ms mientras que con Floyd invertimos 5 * 0.02ms = 0.1ms. En un juego mono-hilo que va a 60 FPS sólo disponemos de 16.6ms para realizar todos los cálculos (IA, colisiones, renderizado).\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"¡2.4 ms de diferencia por frame es una excelente optimización!\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Conclusión express\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Precomputar caminos es mucho menos escalable que hacer los cálculos de forma dinámica pero la mejora de rendimiento es enorme. A pesar de ello, para escenarios grandes puede hacerse una búsqueda de caminos jerárquica (un tema un poco más complejo). Hay que tener cuidado ya que al utilizar Floyd, un cambio en el escenario implicaría una nueva precomputación completa.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","scope":{}},"series":null},"__N_SSG":true}