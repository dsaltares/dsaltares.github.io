{"pageProps":{"metadata":{"path":"content/post/2010-12-26-movimiento-relativo-a-la-camara.mdx","title":"Movimiento relativo a la cámara","date":"2010-12-26T12:52:13.000Z","categories":["Games development"],"series":null,"description":null,"slug":"movimiento-relativo-a-la-camara","readingTime":"6 min read","draft":false,"disableComments":false,"keywords":[],"banner":null},"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    img: \"img\",\n    p: \"p\",\n    strong: \"strong\",\n    h3: \"h3\",\n    em: \"em\",\n    div: \"div\",\n    pre: \"pre\",\n    code: \"code\",\n    ul: \"ul\",\n    li: \"li\",\n    a: \"a\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.img, {\n      src: \"/img/wp/movimiento-camara.png\",\n      alt: \"movimiento-camara.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"En la mayoría de videojuegos en tercera persona, \", _jsx(_components.strong, {\n        children: \"la dirección hacia la que se mueve el personaje depende de la orientación de la cámara\"\n      }), \". A pesar de que Sion Tower es un tower defense, controlamos a un personaje en tercera persona y, por tanto, debía incorporar este sistema. Estos días he estado exprimiendo los sesos para implementar dicho movimiento. ¡Por fin! Tras decenas de diagramas con vectores, ángulos y sistemas de coordenadas, lo he conseguido. En este artículo \", _jsx(_components.strong, {\n        children: \"explico un sencillo algoritmo para conseguirlo\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"¿Qué queremos conseguir?\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"El siguiente diagrama muestra el \", _jsx(_components.strong, {\n        children: \"sistema de coordenadas de Ogre\"\n      }), \". Imaginad que nuestro personaje se encuentra en el origen \", _jsx(_components.em, {\n        children: \"p = (0, 0, 0)\"\n      }), \" y que la cámara está en el \", _jsx(_components.em, {\n        children: \"c = (0, 0, 50)\"\n      }), \" mirando hacia el origen. Nuestras teclas de movimiento son las clásicas: WASD. Al pulsar W el personaje debe moverse en la dirección negativa del eje Z, en cambio, si pulsamos D deberá hacerlo en la dirección positiva del eje X.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"En cambio, si la cámara se situase en \", _jsx(_components.em, {\n        children: \"c = (50, 0, 0)\"\n      }), \" mirando a \", _jsx(_components.em, {\n        children: \"(0, 0, 0)\"\n      }), \" las teclas no tendrían el mismo efecto en términos absolutos, aunque se mantiene idéntico si tomamos como punto de referencia a la cámara. Si pulsamos W el personaje se desplazará en la dirección negativa del eje X. En el caso de que pulsemos D, el personaje se dirigirá en la dirección negativa del eje Z.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/coordenadas.png\",\n      alt: \"coordenadas.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Por supuesto, \", _jsx(_components.strong, {\n        children: \"el personaje deberá girarse\"\n      }), \" para mirar hacia la dirección del desplazamiento. A continuación, detallamos la manera de implementar este sistema de movimiento.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Algoritmo: objetos implicados\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Este pequeño algoritmo está orientado al motor de renderizado Ogre3D y la biblioteca de dispositivos de entrada OIS aunque su filosofía es válida para otras herramientas. Lo ideal sería utilizar clases para el personaje y otros elementos aunque, en esta ocasión, he preferido no hacerlo en favor de la simplicidad del ejemplo.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Partimos de los siguientes objetos:\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"Ogre::SceneNode* nodoPersonaje; // Nodo que representa al personaje\\nOgre::Vector3 direccionObjetivo; // Relativa a la cámara\\nOgre::Vector3 direccionActual; // Relativa a la cámara\\nOgre::Vector3 velocidad; // Velocidad del personaje\\nbool andando; // true si el personaje se está desplazando\\nOIS::Keyboard* teclado; // Teclado para controlar al personaje\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Algoritmo: desplazamiento del personaje\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"En cada frame debemos \", _jsx(_components.strong, {\n        children: \"tomar la dirección de la cámara\"\n      }), \" y quedarnos con su componente x y z ya que nos movemos en el plano. Esa será nuestra dirección \", _jsx(_components.em, {\n        children: \"\\\"hacia delante\\\"\"\n      }), \". Es muy sencillo obtener la dirección \\\"\", _jsx(_components.em, {\n        children: \"hacia la derecha\\\"\"\n      }), \", simplemente intercambiamos las componentes x y z cambiándole el signo a la z de \", _jsx(_components.em, {\n        children: \"\\\"hacia delante\\\"\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"La dirección objetivo\"\n      }), \" de este frame se puede calcular consultando las \", _jsx(_components.strong, {\n        children: \"pulsaciones de las teclas\"\n      }), \" y \", _jsx(_components.strong, {\n        children: \"combinando los dos vectores\"\n      }), \" anteriores utilizando sumas o restas. Nos podremos mover en 8 direcciones distintas. Por ejemplo, si deseamos dirigirnos hacia atrás a la izquierda tendremos: \", _jsx(_components.em, {\n        children: \"direccionObjetivo = -delante – derecha\"\n      }), \". Finalmente, \", _jsx(_components.strong, {\n        children: \"la dirección objetivo debe ser normalizada\"\n      }), \", es decir, que el módulo del vector sea igual a 1. Esto es muy importante si no queremos que la velocidad del personaje se vea alterada. Finalmente, aplicamos el desplazamiento teniendo en cuenta la velocidad, la dirección y el tiempo en milisegundos desde el último frame. Esta técnica se conoce como \", _jsx(_components.strong, {\n        children: \"LERP\"\n      }), \" (Linear Interpolation).\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Algoritmo: orientación del personaje\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Sólo nos queda corregir la orientación del personaje para que mire hacia la dirección en la que se desplaza. Ogre pone a nuestra disposición el método \", _jsx(_components.em, {\n        children: \"Vector3::getRotationTo\"\n      }), \" que, dado un vector nos devuelve el cuaternio a aplicar de forma que tras la rotación quede alineado con el segundo. \", _jsx(_components.strong, {\n        children: \"Los cuaternios se utilizan para representar rotaciones\"\n      }), \" en el espacio y están compuestos por un ángulo y un eje (en este caso el y). Si multiplicamos la rotación necesaria por la que ya posee el nodo del personaje, éste mirará hacia donde deseamos. Es importante el orden de los operadores ya que el producto de cuaternios no es conmutativo.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Algoritmo: código completo\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"He aquí el código completo:\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"using namespace Ogre;\\n\\nvoid EstadoJuego::actualizarPersonaje(Ogre::Real deltaT) {\\n    // Tomamos la dirección de la cámara\\n    Vector3 delante = camara-&gt;getDirection(); \\n    delante.y = 0;\\n\\n    // Vector relativo a la cámara, ortogonal hacia su derecha\\n    Vector3 derecha(-delante.z, 0, delante.x);\\n\\n    // Calculamos la dirección objetivo en función de la pulsación de las\\n    // teclas.\\n    if (teclado-&gt;isKeyDown(OIS::KC_W) &amp;&amp; teclado-&gt;isKeyDown(OIS::KC_D)) {\\n        direccionObjetivo = delante + derecha;\\n        andando = true;\\n    }\\n    else if (teclado-&gt;isKeyDown(OIS::KC_W) &amp;&amp; teclado-&gt;isKeyDown(OIS::KC_A)) {\\n        direccionObjetivo = delante - derecha;\\n        andando = true;\\n    }\\n    else if (teclado-&gt;isKeyDown(OIS::KC_S) &amp;&amp; teclado-&gt;isKeyDown(OIS::KC_D)) {\\n        direccionObjetivo = -delante + derecha;\\n        andando = true;\\n    }\\n    else if (teclado-&gt;isKeyDown(OIS::KC_S) &amp;&amp; teclado-&gt;isKeyDown(OIS::KC_A)) {\\n        direccionObjetivo = -delante - derecha;\\n        andando = true;\\n    }\\n    else if (teclado-&gt;isKeyDown(OIS::KC_W)) {\\n        direccionObjetivo = delante;\\n        andando = true;\\n    }\\n    else if (teclado-&gt;isKeyDown(OIS::KC_S)) {\\n        direccionObjetivo = -delante;\\n        andando = true;\\n    }\\n    else if (teclado-&gt;isKeyDown(OIS::KC_D)) {\\n        direccionObjetivo = derecha;\\n        andando = true;\\n    } \\n    else if (teclado-&gt;isKeyDown(OIS::KC_A)){\\n        direccionObjetivo = -derecha;\\n        andando = true;\\n    }\\n    else\\n        andando = false;\\n\\n    // Normalizamos el vector direccion\\n    direccionObjetivo.normalise();\\n\\n    // Si debemos desplazarnos, aplicamos la traslación y calculamos la\\n    // rotación a aplicar\\n    if (andando) {\\n        nodoPersonaje-&gt;translate(velocidad * direccionObjetivo * deltaT,\\n                                 Node::TS_WORLD);\\n        if (direccionObjetivo != direccionActual) {\\n            Quaternion rotacion = direccionActual.getRotationTo(direccionObjetivo,\\n                                                                Vector3(0, 1, 0));\\n            Quaternion rotacionActual = nodoPersonaje-&gt;getOrientation()\\n            nodoPersonaje-&gt;setOrientation(orientacion * rotacionActual);\\n            direccionActual = direccionObjetivo;\\n        }\\n    }\\n}\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Posibles mejoras\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Este algoritmo no está pensado para incluirse en un juego completo puesto que debe ser refinado. Sólo tenemos en cuenta la animación externa del personaje (desplazamiento y orientación). El algoritmo se olvida completamente de la animación interna. Si quieres un mejor resultado deberías incluirla (andar, detenerse, etc).\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"La rotación es brusca, lo ideal sería aplicarla poco a poco de forma que el personaje se girase suavemente. Para hacerlo deberíamos dividir la rotación en partes y aplicar una en cada frame.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Referencias\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Seguramente quieras consultar fuentes mucho más fiables que yo:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.em, {\n          children: \"Game Engine Architecture (Jason Gregory)\"\n        }), \": libro que cubre todos los aspectos a la hora de desarrollar un motor de juego. Contiene una sección de matemáticas muy bien explicada.\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"http://en.wikipedia.org/wiki/Lerp_%28computing%29\",\n          children: _jsx(_components.em, {\n            children: \"LERP (Wikipedia)\"\n          })\n        })\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"http://www.cprogramming.com/tutorial/3d/quaternions.html\",\n          children: _jsx(_components.em, {\n            children: \"Quaternios (Confuted)\"\n          })\n        }), \": si esto de los cuaternios te ha sonado a chino te recomiendo que consultes este artículo en el que se hace una pequeña introducción.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"http://www.ogre3d.org/docs/api/html/index.html\",\n          children: _jsx(_components.em, {\n            children: \"Documentación oficial de Ogre\"\n          })\n        }), \": para obtener más detalles sobre las clases y los métodos empleados.\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","scope":{}},"series":null},"__N_SSG":true}