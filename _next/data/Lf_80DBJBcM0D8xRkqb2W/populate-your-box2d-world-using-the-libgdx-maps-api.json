{"pageProps":{"metadata":{"path":"content/post/2013-03-09-populate-your-box2d-world-using-the-libgdx-maps-api.mdx","title":"Populate your Box2D world using the libgdx maps API","date":"2013-03-09T18:51:12.000Z","categories":["Games development"],"series":null,"description":null,"slug":"populate-your-box2d-world-using-the-libgdx-maps-api","readingTime":"7 min read","draft":false,"disableComments":false,"keywords":[],"banner":null},"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h3: \"h3\",\n    a: \"a\",\n    img: \"img\",\n    blockquote: \"blockquote\",\n    em: \"em\",\n    div: \"div\",\n    pre: \"pre\",\n    code: \"code\",\n    ul: \"ul\",\n    li: \"li\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"This text proposes an effective approach to painlessly create static collidable geometry in 2D levels with the help of Box2D and the new libgdx maps API.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"All the source code is available for direct download below the post.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"New libgdx maps API\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The mighty libgdx library saw itself to yet another addition a couple of weeks ago, \", _jsx(_components.a, {\n        href: \"http://www.badlogicgames.com/wordpress/?p=2870\",\n        children: \"a shiny brand new maps API\"\n      }), \". Nex and me had been working on it for a while and people seem to be quite happy with it. Actually, by now, loads of folks have contributed too, which is kind of the beauty of open source, isn't it? You might as well read the \", _jsx(_components.a, {\n        href: \"http://code.google.com/p/libgdx/wiki/GraphicsTileMaps?ts=1361648294&updated=GraphicsTileMaps\",\n        children: \"wiki page\"\n      }), \" and check out the \", _jsx(_components.a, {\n        href: \"https://code.google.com/p/libgdx/wiki/GraphicsTileMaps?ts=1361648294&updated=GraphicsTileMaps#Examples\",\n        children: \"sample code\"\n      }), \", luckily enough, there's plenty which is not always the case.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It primarily focuses on modelling how maps data is represented as well as in providing a way of easily implementing loaders and renderers for specific formats. The API comes with built in loaders and renderers for the \", _jsx(_components.a, {\n        href: \"http://www.mapeditor.org/\",\n        children: \"TMX\"\n      }), \", \", _jsx(_components.a, {\n        href: \"http://tide.codeplex.com/\",\n        children: \"Tide\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"http://gleed2d.codeplex.com/\",\n        children: \"Gleed\"\n      }), \" formats. However, the latter might be deprecated at some point in the future due its absolute paths horribleness. Believe me, I've tried to work my way around it but there is just no elegant solution. Although there hasn't been any releases since it's inclusion, it's accessible in the \", _jsx(_components.a, {\n        href: \"http://libgdx.badlogicgames.com/nightlies/\",\n        children: \"nightly builds\"\n      }), \". For those interested in the implementation, please go to the Github repository.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/maps-api-300x125.webp\",\n      alt: \"maps-api-300x125.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Take this cutie as an example, \", _jsx(_components.a, {\n        href: \"https://github.com/libgdx/libgdx/blob/master/tests/gdx-tests/src/com/badlogic/gdx/tests/superkoalio/SuperKoalio.java\",\n        children: \"a minimalistic platformer using the new API\"\n      }), \" in just under 300 lines.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/koalio-300x216.webp\",\n      alt: \"koalio-300x216.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Enjoy.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Use your level editor to place world physics geometry\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's say you\\\"re working on a 2D game which mechanics require some sort of collision detection. Most likely, you\\\"ll be leveraging an editor such as Tiled or Gleed to boost your level creation process. How are you planning to implement collision detection in a way it doesn't become an excruciating pain in the ass to maintain? Can we also make it efficient, please?\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"At last! After all, this is what the article is really about.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you\\\"re going for tile based levels, you could add properties to the map to determine tiles walkability, a perfectly valid approach when presented with just a bunch of tiles. However, adding or changing tiles can become tedious really soon. Why don't you take advantage of Box2D collision detection algorithms and \", _jsx(_components.a, {\n        href: \"http://en.wikipedia.org/wiki/Space_partitioning\",\n        children: \"space partitioning\"\n      }), \" techniques? No worries, you could do so regardless of the need of running a real time physics simulation, just create the bodies, move them according to the game logic and query the world for intersections without stepping it. In case of dealing with a physics based game, then, by all means, make full use of Box2D.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/tiled-caveman-300x154.webp\",\n      alt: \"tiled-caveman-300x154.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"I\\\"m going to assume basic knowledge of this popular physics library, if you don't consider yourself minimally familiar with it, please \", _jsx(_components.a, {\n        href: \"http://box2d.org/manual.pdf\",\n        children: \"take some time to get the basics\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Alright, your textures are all set in your level and it looks stunningly beautiful! Sadly, you lack any kind of collision data. A good practice is to create a separate layer named \", _jsx(_components.em, {\n        children: \"\\\"physics\\\"\"\n      }), \" or similar for sanity reasons. Now you can start placing shapes (rectangles, circles, polygons or polylines) so they adjust to the non walkable areas. Here's an example in my WIP casual abduction game.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/gleed-abduction-collisions-300x158.webp\",\n      alt: \"gleed-abduction-collisions-300x158.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As you could have guessed, having thousands of shapes won't do your game's performance any favours. It\\\"d be a good idea to keep the shape count under control while preserving a decent granularity. Ideally, the editor would have a \", _jsx(_components.em, {\n        children: \"\\\"generate physics\\\"\"\n      }), \" option that would automatically create collision data from a texture layer using \", _jsx(_components.a, {\n        href: \"http://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/alg.html\",\n        children: \"contour tracing\"\n      }), \". Sadly, that's not the case in the state of the art open source software we have today.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Don't forget to hit \", _jsx(_components.em, {\n        children: \"\\\"save\\\"\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Create bodies from your level data > My level has collidable static geometry data, how do I get that in my game?\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To tackle that problem I implemented a simple class named \", _jsx(_components.em, {\n        children: \"MapBodyManager\"\n      }), \" with the following interface.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"public class MapBodyManager {\\n    public MapBodyManager(World world, int unitsPerPixel, String materialsFile);\\n    public void createPhysics(Map map, String layerName);\\n    public void destroyPhysics();\\n}\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"I believe it to be simple enough but I\\\"ll explain the details just in case. The constructor takes the Box2D world so it knows where to dump the new bodies into and where to delete them from later on. Most level editors work in pixels, while Box2D measures stuff in metres (take that imperial system!), hence the need for the \", _jsx(_components.em, {\n        children: \"unitsPerPixel\"\n      }), \" conversion rate. We\\\"ll get to the materials stuff in just a minute.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Once your level is loaded, you just need to do this.\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"MapBodyManager mapBodyManager = new MapBodyManager(world, 1.0f, Gdx.files.internal(&quot;data/materials.json&quot;));\\nMap map = assetManager.get(&quot;data/level.xml&quot;, Map.class);\\nmapBodyManager.createPhysics(map, &quot;physics&quot;);\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This will automatically create a static body per shape in your \", _jsx(_components.em, {\n        children: \"\\\"physics\\\"\"\n      }), \" layer as shown in the screenshot below.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/abduction.webp\",\n      alt: \"abduction.jpg\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So the player heroically beats the level and makes it to the next one. You surely will want to get rid of all those bodies (reference to murder not intended) before adding any more. Interestingly enough, our handy \", _jsx(_components.em, {\n        children: \"MapBodyManager\"\n      }), \" keeps track of all registered bodies, so voilá, easy as cake.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"mapBodyManager.destroyPhysics();\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Material system\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Those who are no strangers to Box2D will know that body's fixtures have properties that determine how they interact with other entities. These are mainly: density, restitution and friction. Mass is usually determined by the area of the shape involved and the fixture's density. Again, check out Box2D documentation for more details on this. We could just create all our static bodies with default properties but…\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"I want to have icy, sandy and elastic surfaces in my game so characters can slide, be slower and bounce!\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"How can our \", _jsx(_components.em, {\n        children: \"MapBodyManager\"\n      }), \" deal with all this? It's actually dead easy, I went for a very simple material system where each one of these materials are defined by a set of properties in a straightforward JSON file. Let's say that the game world we want to model has regular, ice and elastic elements, we might be able to get away with something such as this.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"[\\n  { &quot;name&quot; : &quot;ice&quot;, &quot;density&quot; : 1.0, &quot;restitution&quot; : 0.0, &quot;friction&quot; : 0.1 },\\n  { &quot;name&quot; : &quot;elastic&quot;, &quot;density&quot; : 1.0, &quot;restitution&quot; : 0.8, &quot;friction&quot; : 0.8 }\\n]\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Assigning materials to elements in our editor is also fairly simple. Add a \", _jsx(_components.em, {\n        children: \"\\\"material\\\"\"\n      }), \" custom property per shape you want to behave in a non default manner. Every editor has its own GUI element for this and all of them are almost identical.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/img/wp/material.webp\",\n      alt: \"material.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.em, {\n        children: \"MapBodyManager\"\n      }), \" will automatically pick up each shape's material and create bodies with the desired properties. Adding new materials is trivial and, whilst reassigning them is not comfortable, it's not a deal breaker either.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This makes you happy, doesn't it?\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"Yay! ### Source code\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Did you read this all or did you just scrolled down after realising you could download the source at the end? If you belong to the first group, I have to say you\\\"re awesome and deserve my most sincere admiration.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Nevertheless, you\\\"ll be very disappointed to see there's no arcane magic going on behind the scenes as the implementation is not shocking in any way. Here it goes for those who are bored enough and wouldn't mind to procrastinate some more by reading a piece useless code.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As promised.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://github.com/dsaltares/sioncore/blob/master/src/com/siondream/core/physics/MapBodyManager.java\",\n        children: \"MapBodyManager.java\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To be honest, I've only tested this with Gleed created maps and I don't intend to maintain this utility class any further than what I deem necessary to carry on with my projects. The API is homogeneous and should be fully compatible with Tiled and Tide as it is. Worst case scenario, if you bump into problems, the fixes are likely to be simple. Obviously, you\\\"re not forced to use it, feel free to mimic the approach and pick ideas from it, you\\\"ll probably come up with something better after some thought.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Edit 1\"\n        }), \": updated the code to support latest Libgdx API and fixed bugs.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Edit 2\"\n        }), \": changed materials file format from XML to JSON.\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","scope":{}},"series":null},"__N_SSG":true}