{"pageProps":{"metadata":{"path":"content/post/2014-04-24-listenerset-using-variadic-templates.mdx","title":"ListenerSet using variadic templates","date":"2014-04-24T10:00:02.000Z","categories":["Computing"],"series":null,"description":null,"slug":"listenerset-using-variadic-templates","readingTime":"5 min read","draft":false,"disableComments":false,"keywords":[],"banner":null},"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    strong: \"strong\",\n    a: \"a\",\n    h3: \"h3\",\n    code: \"code\",\n    div: \"div\",\n    pre: \"pre\",\n    em: \"em\",\n    blockquote: \"blockquote\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Important\"\n      }), \": variadic templates are only available from C++11, make sure your compiler supports it.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Who has never used the \", _jsx(_components.a, {\n        href: \"http://en.wikipedia.org/wiki/Observer_pattern\",\n        children: \"Observer\"\n      }), \" pattern? As long as you have been involved in any medium sized project, chances are you have come across it at some point.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"The problem\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It is extremely common to have an event generating system other components would like to subscribe to. However, oftentimes I see code to manage a collection of listeners being unnecessarily duplicated on a per system basis. That is registration, un-registration and notification. A lot of nonsensical boilerplate, which makes for code that is harder to read and easier to get wrong.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let's take a look at a typical input event dispatching system, simplified for the purposes of this article. We could have an \", _jsx(_components.code, {\n        children: \"IInputListener\"\n      }), \" interface that handles a couple of events, \", _jsx(_components.code, {\n        children: \"keyDown()\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"keyUp()\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"struct IInputListener\\n{\\n    virtual ~IInputListener() {}\\n    virtual bool keyDown(KeyCode code) = 0;\\n    virtual bool keyUp(KeyCode code) = 0;\\n};\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Our \", _jsx(_components.code, {\n        children: \"InputSystem\"\n      }), \" class could hold an \", _jsx(_components.code, {\n        children: \"std::set\"\n      }), \" of \", _jsx(_components.code, {\n        children: \"IInputListener\"\n      }), \" pointers. Registration and un-registration is made possible through \", _jsx(_components.code, {\n        children: \"addListener()\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"removeListener()\"\n      }), \" respectively. Bad news is that, every single time we want to send an event to the listeners, we are forced to iterate over the collection. Also, God kills a kitten.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"class InputSystem\\n{\\npublic:\\n    void addListener(IInputListener* listener)\\n    {\\n        m_listeners.insert(listener);\\n    }\\n\\n    void removeListener(IInputListener* listener)\\n    {\\n        m_listeners.erase(listener);\\n    }\\n\\n    void update()\\n    {\\n        // Touch down detected\\n        for (auto listener : m_listeners)\\n        {\\n            listener-&gt;keyDown(code);\\n        }\\n\\n        ...\\n\\n        // Touch up detected\\n        for (auto listener : m_listeners)\\n        {\\n            listener-&gt;keyUp(code);\\n        }\\n    }\\n\\nprivate:\\n    std::set&lt;IInputListener*&gt; m_listeners;\\n};\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As if this wasn't enough, there is another important \", _jsx(_components.em, {\n        children: \"gotcha\"\n      }), \" here. What happens when a listener un-registers as a result of an event? The \", _jsx(_components.code, {\n        children: \"m_listeners\"\n      }), \" collection is modified in the middle of the \", _jsx(_components.code, {\n        children: \"for\"\n      }), \" loop, thus current iterators are no longer valid. The second we try to increment the internal iterator to fetch the next listener.\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"BAM!\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Not good.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The solution is simple but annoying. We can just add new listener registration and un-registration requests to a pending list while in the middle of a dispatch. Those pending lists would be processed once it's safe to modify the collection of listeners.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Moreover, some people use \", _jsx(_components.code, {\n        children: \"std::vector\"\n      }), \" instead of \", _jsx(_components.code, {\n        children: \"std::set\"\n      }), \" for performance reasons, which is completely legit. However, that involves adding code to ensure listener uniqueness in the collection.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Every time.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Honestly? I'm lazy so I don't want to be the guy who implements this over and over.\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"Okay, so what do you suggest?\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"The way towards the solution\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Following our intuition, we realise that a way to generalise this behaviour is in order. Ideally, it would meet the following criteria.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Avoids all code duplication.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Ensures listener uniqueness.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"It is safe, can register, un-register while notifying.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Avoids manually going through the listener collection to send an event.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Compatible with any kind of event listener.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Intuitively, we could have a \", _jsx(_components.code, {\n        children: \"ListenerSet<Type>\"\n      }), \" template class that handles listener duplication as well as registration and un-registration safety.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Note\"\n      }), \": we'll be using \", _jsx(_components.code, {\n        children: \"std::set\"\n      }), \" rather than \", _jsx(_components.code, {\n        children: \"std::vector\"\n      }), \" for simplicity. Both can be used as long as the appropriate precautions are taken.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"template &lt;class Type&gt; class ListenerSet\\n{\\npublic:\\n    ListenerSet() {}\\n    virtual ~ListenerSet() {}\\n\\n    inline void addListener(Type listener)\\n    {\\n        if (m_notifying)\\n        {\\n            m_pendingAddition.insert(listener);\\n            m_pendingRemoval.erase(listener);\\n        }\\n        else\\n        {\\n            m_listeners.insert(listener);\\n        }\\n    }\\n\\n    inline void removeListener(Type listener)\\n    {\\n        if (m_notifying)\\n        {\\n            m_pendingRemoval.insert(listener);\\n            m_pendingAddition.erase(listener);\\n        }\\n        else\\n        {\\n            m_listeners.erase(listener);\\n        }\\n    }\\n\\nprivate:\\n    bool m_notifying;\\n    std::set&lt;Type&gt; m_pendingRemoval;\\n    std::set&lt;Type&gt; m_pendingAddition;\\n    std::set&lt;Type&gt; m_listeners;\\n};\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We're missing the notification functionality, that's the tricky part. We would like to have an interface such as to be able to do something like this.\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"m_listenerSet.notify(&amp;IInputListener::keyDown, keyCode);\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"ListenerSet::notify()\"\n      }), \" would iterate over all the registered listeners calling \", _jsx(_components.code, {\n        children: \"IInputListener::keyDown\"\n      }), \" and passing \", _jsx(_components.code, {\n        children: \"keyCode\"\n      }), \" as a parameter.\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"Maybe easier said than done?\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"True, \", _jsx(_components.code, {\n        children: \"ListenerSet::notify()\"\n      }), \" needs to support an arbitrary number of arguments, as different event handlers won't necessarily have the same signature. Moreover, \", _jsx(_components.code, {\n        children: \"IInputListener::keyDown\"\n      }), \"(and every other potential handler) needs to receive a \", _jsx(_components.code, {\n        children: \"this\"\n      }), \" pointer along the remaining arguments.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This is where \", _jsx(_components.a, {\n        href: \"http://www.cplusplus.com/articles/EhvU7k9E/\",\n        children: \"variadic templates\"\n      }), \" come into play. Basically, they're templates that can take an arbitrary number of parameters of any type.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Interestingly enough, \", _jsx(_components.code, {\n        children: \"std::bind()\"\n      }), \" also takes an arbitrary number of parameters. That means we can create an \", _jsx(_components.code, {\n        children: \"std::function>\"\n      }), \" object that has everything we need: the event handler function pointer, \", _jsx(_components.code, {\n        children: \"this\"\n      }), \" and the remaining arguments.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Take a look at the code.\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"template &lt;class Function, class... Arguments&gt;\\ninline void notify(Function&amp;&amp; f, Arguments&amp;&amp;... args)\\n{\\n    m_notifying = true;\\n    for (Type listener : m_listeners)\\n    {\\n        auto callback = std::bind(f, listener, args...);\\n        callback(listener);\\n    }\\n    m_notifying = false;\\n\\n    for (Type listener : m_pendingRemoval)\\n    {\\n        m_listeners.erase(listener);\\n    }\\n\\n    m_pendingRemoval.clear();\\n\\n    for (Type listener : m_pendingAddition)\\n    {\\n        m_listeners.insert(listener);\\n    }\\n\\n    m_pendingAddition.clear();\\n}\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Note how we process the pending requests to add or remove listeners after we finish sending the events, that's when it's safe.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now we can do exactly what we wanted!\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"remark-highlight\",\n      children: _jsx(_components.pre, {\n        className: \"language-unknown\",\n        children: _jsx(_components.code, {\n          className: \"language-unknown\",\n          children: \"ListenerSet&lt;IInputListener*&gt; listeners;\\n\\nlisteners.addListener(new PlayerInputListener());\\nlisteners.addListener(new UserInterfaceInputListener());\\n\\nm_listenerSet.notify(&amp;IInputListener::keyDown, keyCode);\\nm_listenerSet.notify(&amp;IInputListener::keyUp, keyCode);\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Templates are instantiated at compile time, which means the compiler will complain if we're doing something dodgy such as trying to bind the wrong thing. Compile time checks are good.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Managing a set of listeners and sending events is now a lot easier, safer and readable. Last but not least, it's significantly less error prone.\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"Hooray!!!\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Full source\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For those interested, I've made the code available as a GitHub Gist.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://gist.github.com/dsaltares/11212605\",\n        children: \"ListenerSet implementation\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","scope":{}},"series":null},"__N_SSG":true}